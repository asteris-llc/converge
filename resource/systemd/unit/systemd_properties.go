// Copyright Â© 2017 Asteris, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by generate-dbus-wrappers
// DO NOT EDIT!

package unit

// Properties wraps the dbus api for system with properties from this unit type
type Properties struct {
	ActiveEnterTimestamp            uint64          `export:"ActiveEnterTimestamp"`
	ActiveEnterTimestampMonotonic   uint64          `export:"ActiveEnterTimestampMonotonic"`
	ActiveExitTimestamp             uint64          `export:"ActiveExitTimestamp"`
	ActiveExitTimestampMonotonic    uint64          `export:"ActiveExitTimestampMonotonic"`
	ActiveState                     string          `export:"ActiveState"`
	After                           []string        `export:"After"`
	AllowIsolate                    bool            `export:"AllowIsolate"`
	AssertResult                    bool            `export:"AssertResult"`
	AssertTimestamp                 uint64          `export:"AssertTimestamp"`
	AssertTimestampMonotonic        uint64          `export:"AssertTimestampMonotonic"`
	Asserts                         [][]interface{} `export:"Asserts"`
	Before                          []string        `export:"Before"`
	BindsTo                         []string        `export:"BindsTo"`
	BoundBy                         []string        `export:"BoundBy"`
	CanIsolate                      bool            `export:"CanIsolate"`
	CanReload                       bool            `export:"CanReload"`
	CanStart                        bool            `export:"CanStart"`
	CanStop                         bool            `export:"CanStop"`
	ConditionResult                 bool            `export:"ConditionResult"`
	ConditionTimestamp              uint64          `export:"ConditionTimestamp"`
	ConditionTimestampMonotonic     uint64          `export:"ConditionTimestampMonotonic"`
	Conditions                      [][]interface{} `export:"Conditions"`
	ConflictedBy                    []string        `export:"ConflictedBy"`
	Conflicts                       []string        `export:"Conflicts"`
	ConsistsOf                      []string        `export:"ConsistsOf"`
	DefaultDependencies             bool            `export:"DefaultDependencies"`
	Description                     string          `export:"Description"`
	Documentation                   []string        `export:"Documentation"`
	DropInPaths                     []string        `export:"DropInPaths"`
	Following                       string          `export:"Following"`
	FragmentPath                    string          `export:"FragmentPath"`
	Id                              string          `export:"Id"`
	IgnoreOnIsolate                 bool            `export:"IgnoreOnIsolate"`
	InactiveEnterTimestamp          uint64          `export:"InactiveEnterTimestamp"`
	InactiveEnterTimestampMonotonic uint64          `export:"InactiveEnterTimestampMonotonic"`
	InactiveExitTimestamp           uint64          `export:"InactiveExitTimestamp"`
	InactiveExitTimestampMonotonic  uint64          `export:"InactiveExitTimestampMonotonic"`
	Job                             []interface{}   `export:"Job"`
	JobTimeoutAction                string          `export:"JobTimeoutAction"`
	JobTimeoutRebootArgument        string          `export:"JobTimeoutRebootArgument"`
	JobTimeoutUSec                  uint64          `export:"JobTimeoutUSec"`
	JoinsNamespaceOf                []string        `export:"JoinsNamespaceOf"`
	LoadError                       []interface{}   `export:"LoadError"`
	LoadState                       string          `export:"LoadState"`
	Names                           []string        `export:"Names"`
	NeedDaemonReload                bool            `export:"NeedDaemonReload"`
	OnFailure                       []string        `export:"OnFailure"`
	OnFailureJobMode                string          `export:"OnFailureJobMode"`
	PartOf                          []string        `export:"PartOf"`
	PropagatesReloadTo              []string        `export:"PropagatesReloadTo"`
	RebootArgument                  string          `export:"RebootArgument"`
	RefuseManualStart               bool            `export:"RefuseManualStart"`
	RefuseManualStop                bool            `export:"RefuseManualStop"`
	ReloadPropagatedFrom            []string        `export:"ReloadPropagatedFrom"`
	RequiredBy                      []string        `export:"RequiredBy"`
	Requires                        []string        `export:"Requires"`
	RequiresMountsFor               []string        `export:"RequiresMountsFor"`
	Requisite                       []string        `export:"Requisite"`
	RequisiteOf                     []string        `export:"RequisiteOf"`
	SourcePath                      string          `export:"SourcePath"`
	StartLimitAction                string          `export:"StartLimitAction"`
	StartLimitBurst                 uint32          `export:"StartLimitBurst"`
	StartLimitInterval              uint64          `export:"StartLimitInterval"`
	StateChangeTimestamp            uint64          `export:"StateChangeTimestamp"`
	StateChangeTimestampMonotonic   uint64          `export:"StateChangeTimestampMonotonic"`
	StopWhenUnneeded                bool            `export:"StopWhenUnneeded"`
	SubState                        string          `export:"SubState"`
	Transient                       bool            `export:"Transient"`
	TriggeredBy                     []string        `export:"TriggeredBy"`
	Triggers                        []string        `export:"Triggers"`
	UnitFilePreset                  string          `export:"UnitFilePreset"`
	UnitFileState                   string          `export:"UnitFileState"`
	WantedBy                        []string        `export:"WantedBy"`
	Wants                           []string        `export:"Wants"`
}

// newPropertiesFromMap generates a new Properties given a systemd property map
func newPropertiesFromMap(m map[string]interface{}) *Properties {
	s := &Properties{}

	if val, ok := m["ActiveEnterTimestamp"]; ok {
		s.ActiveEnterTimestamp = val.(uint64)
	}

	if val, ok := m["ActiveEnterTimestampMonotonic"]; ok {
		s.ActiveEnterTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["ActiveExitTimestamp"]; ok {
		s.ActiveExitTimestamp = val.(uint64)
	}

	if val, ok := m["ActiveExitTimestampMonotonic"]; ok {
		s.ActiveExitTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["ActiveState"]; ok {
		s.ActiveState = val.(string)
	}

	if val, ok := m["After"]; ok {
		s.After = val.([]string)
	}

	if val, ok := m["AllowIsolate"]; ok {
		s.AllowIsolate = val.(bool)
	}

	if val, ok := m["AssertResult"]; ok {
		s.AssertResult = val.(bool)
	}

	if val, ok := m["AssertTimestamp"]; ok {
		s.AssertTimestamp = val.(uint64)
	}

	if val, ok := m["AssertTimestampMonotonic"]; ok {
		s.AssertTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["Asserts"]; ok {
		s.Asserts = val.([][]interface{})
	}

	if val, ok := m["Before"]; ok {
		s.Before = val.([]string)
	}

	if val, ok := m["BindsTo"]; ok {
		s.BindsTo = val.([]string)
	}

	if val, ok := m["BoundBy"]; ok {
		s.BoundBy = val.([]string)
	}

	if val, ok := m["CanIsolate"]; ok {
		s.CanIsolate = val.(bool)
	}

	if val, ok := m["CanReload"]; ok {
		s.CanReload = val.(bool)
	}

	if val, ok := m["CanStart"]; ok {
		s.CanStart = val.(bool)
	}

	if val, ok := m["CanStop"]; ok {
		s.CanStop = val.(bool)
	}

	if val, ok := m["ConditionResult"]; ok {
		s.ConditionResult = val.(bool)
	}

	if val, ok := m["ConditionTimestamp"]; ok {
		s.ConditionTimestamp = val.(uint64)
	}

	if val, ok := m["ConditionTimestampMonotonic"]; ok {
		s.ConditionTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["Conditions"]; ok {
		s.Conditions = val.([][]interface{})
	}

	if val, ok := m["ConflictedBy"]; ok {
		s.ConflictedBy = val.([]string)
	}

	if val, ok := m["Conflicts"]; ok {
		s.Conflicts = val.([]string)
	}

	if val, ok := m["ConsistsOf"]; ok {
		s.ConsistsOf = val.([]string)
	}

	if val, ok := m["DefaultDependencies"]; ok {
		s.DefaultDependencies = val.(bool)
	}

	if val, ok := m["Description"]; ok {
		s.Description = val.(string)
	}

	if val, ok := m["Documentation"]; ok {
		s.Documentation = val.([]string)
	}

	if val, ok := m["DropInPaths"]; ok {
		s.DropInPaths = val.([]string)
	}

	if val, ok := m["Following"]; ok {
		s.Following = val.(string)
	}

	if val, ok := m["FragmentPath"]; ok {
		s.FragmentPath = val.(string)
	}

	if val, ok := m["Id"]; ok {
		s.Id = val.(string)
	}

	if val, ok := m["IgnoreOnIsolate"]; ok {
		s.IgnoreOnIsolate = val.(bool)
	}

	if val, ok := m["InactiveEnterTimestamp"]; ok {
		s.InactiveEnterTimestamp = val.(uint64)
	}

	if val, ok := m["InactiveEnterTimestampMonotonic"]; ok {
		s.InactiveEnterTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["InactiveExitTimestamp"]; ok {
		s.InactiveExitTimestamp = val.(uint64)
	}

	if val, ok := m["InactiveExitTimestampMonotonic"]; ok {
		s.InactiveExitTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["Job"]; ok {
		s.Job = val.([]interface{})
	}

	if val, ok := m["JobTimeoutAction"]; ok {
		s.JobTimeoutAction = val.(string)
	}

	if val, ok := m["JobTimeoutRebootArgument"]; ok {
		s.JobTimeoutRebootArgument = val.(string)
	}

	if val, ok := m["JobTimeoutUSec"]; ok {
		s.JobTimeoutUSec = val.(uint64)
	}

	if val, ok := m["JoinsNamespaceOf"]; ok {
		s.JoinsNamespaceOf = val.([]string)
	}

	if val, ok := m["LoadError"]; ok {
		s.LoadError = val.([]interface{})
	}

	if val, ok := m["LoadState"]; ok {
		s.LoadState = val.(string)
	}

	if val, ok := m["Names"]; ok {
		s.Names = val.([]string)
	}

	if val, ok := m["NeedDaemonReload"]; ok {
		s.NeedDaemonReload = val.(bool)
	}

	if val, ok := m["OnFailure"]; ok {
		s.OnFailure = val.([]string)
	}

	if val, ok := m["OnFailureJobMode"]; ok {
		s.OnFailureJobMode = val.(string)
	}

	if val, ok := m["PartOf"]; ok {
		s.PartOf = val.([]string)
	}

	if val, ok := m["PropagatesReloadTo"]; ok {
		s.PropagatesReloadTo = val.([]string)
	}

	if val, ok := m["RebootArgument"]; ok {
		s.RebootArgument = val.(string)
	}

	if val, ok := m["RefuseManualStart"]; ok {
		s.RefuseManualStart = val.(bool)
	}

	if val, ok := m["RefuseManualStop"]; ok {
		s.RefuseManualStop = val.(bool)
	}

	if val, ok := m["ReloadPropagatedFrom"]; ok {
		s.ReloadPropagatedFrom = val.([]string)
	}

	if val, ok := m["RequiredBy"]; ok {
		s.RequiredBy = val.([]string)
	}

	if val, ok := m["Requires"]; ok {
		s.Requires = val.([]string)
	}

	if val, ok := m["RequiresMountsFor"]; ok {
		s.RequiresMountsFor = val.([]string)
	}

	if val, ok := m["Requisite"]; ok {
		s.Requisite = val.([]string)
	}

	if val, ok := m["RequisiteOf"]; ok {
		s.RequisiteOf = val.([]string)
	}

	if val, ok := m["SourcePath"]; ok {
		s.SourcePath = val.(string)
	}

	if val, ok := m["StartLimitAction"]; ok {
		s.StartLimitAction = val.(string)
	}

	if val, ok := m["StartLimitBurst"]; ok {
		s.StartLimitBurst = val.(uint32)
	}

	if val, ok := m["StartLimitInterval"]; ok {
		s.StartLimitInterval = val.(uint64)
	}

	if val, ok := m["StateChangeTimestamp"]; ok {
		s.StateChangeTimestamp = val.(uint64)
	}

	if val, ok := m["StateChangeTimestampMonotonic"]; ok {
		s.StateChangeTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["StopWhenUnneeded"]; ok {
		s.StopWhenUnneeded = val.(bool)
	}

	if val, ok := m["SubState"]; ok {
		s.SubState = val.(string)
	}

	if val, ok := m["Transient"]; ok {
		s.Transient = val.(bool)
	}

	if val, ok := m["TriggeredBy"]; ok {
		s.TriggeredBy = val.([]string)
	}

	if val, ok := m["Triggers"]; ok {
		s.Triggers = val.([]string)
	}

	if val, ok := m["UnitFilePreset"]; ok {
		s.UnitFilePreset = val.(string)
	}

	if val, ok := m["UnitFileState"]; ok {
		s.UnitFileState = val.(string)
	}

	if val, ok := m["WantedBy"]; ok {
		s.WantedBy = val.([]string)
	}

	if val, ok := m["Wants"]; ok {
		s.Wants = val.([]string)
	}
	return s
}

// ServiceTypeProperties wraps the dbus api for system with properties from this unit type
type ServiceTypeProperties struct {
	AmbientCapabilities             uint64          `export:"AmbientCapabilities"`
	AppArmorProfile                 []interface{}   `export:"AppArmorProfile"`
	BlockIOAccounting               bool            `export:"BlockIOAccounting"`
	BlockIODeviceWeight             [][]interface{} `export:"BlockIODeviceWeight"`
	BlockIOReadBandwidth            [][]interface{} `export:"BlockIOReadBandwidth"`
	BlockIOWeight                   uint64          `export:"BlockIOWeight"`
	BlockIOWriteBandwidth           [][]interface{} `export:"BlockIOWriteBandwidth"`
	BusName                         string          `export:"BusName"`
	CPUAccounting                   bool            `export:"CPUAccounting"`
	CPUAffinity                     []uint8         `export:"CPUAffinity"`
	CPUQuotaPerSecUSec              uint64          `export:"CPUQuotaPerSecUSec"`
	CPUSchedulingPolicy             int32           `export:"CPUSchedulingPolicy"`
	CPUSchedulingPriority           int32           `export:"CPUSchedulingPriority"`
	CPUSchedulingResetOnFork        bool            `export:"CPUSchedulingResetOnFork"`
	CPUShares                       uint64          `export:"CPUShares"`
	CPUUsageNSec                    uint64          `export:"CPUUsageNSec"`
	Capabilities                    string          `export:"Capabilities"`
	CapabilityBoundingSet           uint64          `export:"CapabilityBoundingSet"`
	ControlGroup                    string          `export:"ControlGroup"`
	ControlPID                      uint32          `export:"ControlPID"`
	Delegate                        bool            `export:"Delegate"`
	DeviceAllow                     [][]interface{} `export:"DeviceAllow"`
	DevicePolicy                    string          `export:"DevicePolicy"`
	Environment                     []string        `export:"Environment"`
	EnvironmentFiles                [][]interface{} `export:"EnvironmentFiles"`
	ExecMainCode                    int32           `export:"ExecMainCode"`
	ExecMainExitTimestamp           uint64          `export:"ExecMainExitTimestamp"`
	ExecMainExitTimestampMonotonic  uint64          `export:"ExecMainExitTimestampMonotonic"`
	ExecMainPID                     uint32          `export:"ExecMainPID"`
	ExecMainStartTimestamp          uint64          `export:"ExecMainStartTimestamp"`
	ExecMainStartTimestampMonotonic uint64          `export:"ExecMainStartTimestampMonotonic"`
	ExecMainStatus                  int32           `export:"ExecMainStatus"`
	ExecReload                      [][]interface{} `export:"ExecReload"`
	ExecStart                       [][]interface{} `export:"ExecStart"`
	ExecStartPost                   [][]interface{} `export:"ExecStartPost"`
	ExecStartPre                    [][]interface{} `export:"ExecStartPre"`
	ExecStop                        [][]interface{} `export:"ExecStop"`
	ExecStopPost                    [][]interface{} `export:"ExecStopPost"`
	FailureAction                   string          `export:"FailureAction"`
	FileDescriptorStoreMax          uint32          `export:"FileDescriptorStoreMax"`
	Group                           string          `export:"Group"`
	GuessMainPID                    bool            `export:"GuessMainPID"`
	IOScheduling                    int32           `export:"IOScheduling"`
	IgnoreSIGPIPE                   bool            `export:"IgnoreSIGPIPE"`
	InaccessibleDirectories         []string        `export:"InaccessibleDirectories"`
	KillMode                        string          `export:"KillMode"`
	KillSignal                      int32           `export:"KillSignal"`
	LimitAS                         uint64          `export:"LimitAS"`
	LimitASSoft                     uint64          `export:"LimitASSoft"`
	LimitCORE                       uint64          `export:"LimitCORE"`
	LimitCORESoft                   uint64          `export:"LimitCORESoft"`
	LimitCPU                        uint64          `export:"LimitCPU"`
	LimitCPUSoft                    uint64          `export:"LimitCPUSoft"`
	LimitDATA                       uint64          `export:"LimitDATA"`
	LimitDATASoft                   uint64          `export:"LimitDATASoft"`
	LimitFSIZE                      uint64          `export:"LimitFSIZE"`
	LimitFSIZESoft                  uint64          `export:"LimitFSIZESoft"`
	LimitLOCKS                      uint64          `export:"LimitLOCKS"`
	LimitLOCKSSoft                  uint64          `export:"LimitLOCKSSoft"`
	LimitMEMLOCK                    uint64          `export:"LimitMEMLOCK"`
	LimitMEMLOCKSoft                uint64          `export:"LimitMEMLOCKSoft"`
	LimitMSGQUEUE                   uint64          `export:"LimitMSGQUEUE"`
	LimitMSGQUEUESoft               uint64          `export:"LimitMSGQUEUESoft"`
	LimitNICE                       uint64          `export:"LimitNICE"`
	LimitNICESoft                   uint64          `export:"LimitNICESoft"`
	LimitNOFILE                     uint64          `export:"LimitNOFILE"`
	LimitNOFILESoft                 uint64          `export:"LimitNOFILESoft"`
	LimitNPROC                      uint64          `export:"LimitNPROC"`
	LimitNPROCSoft                  uint64          `export:"LimitNPROCSoft"`
	LimitRSS                        uint64          `export:"LimitRSS"`
	LimitRSSSoft                    uint64          `export:"LimitRSSSoft"`
	LimitRTPRIO                     uint64          `export:"LimitRTPRIO"`
	LimitRTPRIOSoft                 uint64          `export:"LimitRTPRIOSoft"`
	LimitRTTIME                     uint64          `export:"LimitRTTIME"`
	LimitRTTIMESoft                 uint64          `export:"LimitRTTIMESoft"`
	LimitSIGPENDING                 uint64          `export:"LimitSIGPENDING"`
	LimitSIGPENDINGSoft             uint64          `export:"LimitSIGPENDINGSoft"`
	LimitSTACK                      uint64          `export:"LimitSTACK"`
	LimitSTACKSoft                  uint64          `export:"LimitSTACKSoft"`
	MainPID                         uint32          `export:"MainPID"`
	MemoryAccounting                bool            `export:"MemoryAccounting"`
	MemoryCurrent                   uint64          `export:"MemoryCurrent"`
	MemoryLimit                     uint64          `export:"MemoryLimit"`
	MountFlags                      uint64          `export:"MountFlags"`
	NFileDescriptorStore            uint32          `export:"NFileDescriptorStore"`
	Nice                            int32           `export:"Nice"`
	NoNewPrivileges                 bool            `export:"NoNewPrivileges"`
	NonBlocking                     bool            `export:"NonBlocking"`
	NotifyAccess                    string          `export:"NotifyAccess"`
	OOMScoreAdjust                  int32           `export:"OOMScoreAdjust"`
	PAMName                         string          `export:"PAMName"`
	PIDFile                         string          `export:"PIDFile"`
	PassEnvironment                 []string        `export:"PassEnvironment"`
	PermissionsStartOnly            bool            `export:"PermissionsStartOnly"`
	Personality                     string          `export:"Personality"`
	PrivateDevices                  bool            `export:"PrivateDevices"`
	PrivateNetwork                  bool            `export:"PrivateNetwork"`
	PrivateTmp                      bool            `export:"PrivateTmp"`
	ProtectHome                     string          `export:"ProtectHome"`
	ProtectSystem                   string          `export:"ProtectSystem"`
	ReadOnlyDirectories             []string        `export:"ReadOnlyDirectories"`
	ReadWriteDirectories            []string        `export:"ReadWriteDirectories"`
	RemainAfterExit                 bool            `export:"RemainAfterExit"`
	Restart                         string          `export:"Restart"`
	RestartUSec                     uint64          `export:"RestartUSec"`
	RestrictAddressFamilies         []interface{}   `export:"RestrictAddressFamilies"`
	Result                          string          `export:"Result"`
	RootDirectory                   string          `export:"RootDirectory"`
	RootDirectoryStartOnly          bool            `export:"RootDirectoryStartOnly"`
	RuntimeDirectory                []string        `export:"RuntimeDirectory"`
	RuntimeDirectoryMode            uint32          `export:"RuntimeDirectoryMode"`
	RuntimeMaxUSec                  uint64          `export:"RuntimeMaxUSec"`
	SELinuxContext                  []interface{}   `export:"SELinuxContext"`
	SameProcessGroup                bool            `export:"SameProcessGroup"`
	SecureBits                      int32           `export:"SecureBits"`
	SendSIGHUP                      bool            `export:"SendSIGHUP"`
	SendSIGKILL                     bool            `export:"SendSIGKILL"`
	Slice                           string          `export:"Slice"`
	SmackProcessLabel               []interface{}   `export:"SmackProcessLabel"`
	StandardError                   string          `export:"StandardError"`
	StandardInput                   string          `export:"StandardInput"`
	StandardOutput                  string          `export:"StandardOutput"`
	StartupBlockIOWeight            uint64          `export:"StartupBlockIOWeight"`
	StartupCPUShares                uint64          `export:"StartupCPUShares"`
	StatusErrno                     int32           `export:"StatusErrno"`
	StatusText                      string          `export:"StatusText"`
	SupplementaryGroups             []string        `export:"SupplementaryGroups"`
	SyslogFacility                  int32           `export:"SyslogFacility"`
	SyslogIdentifier                string          `export:"SyslogIdentifier"`
	SyslogLevel                     int32           `export:"SyslogLevel"`
	SyslogLevelPrefix               bool            `export:"SyslogLevelPrefix"`
	SyslogPriority                  int32           `export:"SyslogPriority"`
	SystemCallArchitectures         []string        `export:"SystemCallArchitectures"`
	SystemCallErrorNumber           int32           `export:"SystemCallErrorNumber"`
	SystemCallFilter                []interface{}   `export:"SystemCallFilter"`
	TTYPath                         string          `export:"TTYPath"`
	TTYReset                        bool            `export:"TTYReset"`
	TTYVHangup                      bool            `export:"TTYVHangup"`
	TTYVTDisallocate                bool            `export:"TTYVTDisallocate"`
	TasksAccounting                 bool            `export:"TasksAccounting"`
	TasksCurrent                    uint64          `export:"TasksCurrent"`
	TasksMax                        uint64          `export:"TasksMax"`
	TimeoutStartUSec                uint64          `export:"TimeoutStartUSec"`
	TimeoutStopUSec                 uint64          `export:"TimeoutStopUSec"`
	TimerSlackNSec                  uint64          `export:"TimerSlackNSec"`
	Type                            string          `export:"Type"`
	UMask                           uint32          `export:"UMask"`
	USBFunctionDescriptors          string          `export:"USBFunctionDescriptors"`
	USBFunctionStrings              string          `export:"USBFunctionStrings"`
	User                            string          `export:"User"`
	UtmpIdentifier                  string          `export:"UtmpIdentifier"`
	UtmpMode                        string          `export:"UtmpMode"`
	WatchdogTimestamp               uint64          `export:"WatchdogTimestamp"`
	WatchdogTimestampMonotonic      uint64          `export:"WatchdogTimestampMonotonic"`
	WatchdogUSec                    uint64          `export:"WatchdogUSec"`
	WorkingDirectory                string          `export:"WorkingDirectory"`
}

// newServiceTypePropertiesFromMap generates a new ServiceTypeProperties given a systemd property map
func newServiceTypePropertiesFromMap(m map[string]interface{}) *ServiceTypeProperties {
	s := &ServiceTypeProperties{}

	if val, ok := m["AmbientCapabilities"]; ok {
		s.AmbientCapabilities = val.(uint64)
	}

	if val, ok := m["AppArmorProfile"]; ok {
		s.AppArmorProfile = val.([]interface{})
	}

	if val, ok := m["BlockIOAccounting"]; ok {
		s.BlockIOAccounting = val.(bool)
	}

	if val, ok := m["BlockIODeviceWeight"]; ok {
		s.BlockIODeviceWeight = val.([][]interface{})
	}

	if val, ok := m["BlockIOReadBandwidth"]; ok {
		s.BlockIOReadBandwidth = val.([][]interface{})
	}

	if val, ok := m["BlockIOWeight"]; ok {
		s.BlockIOWeight = val.(uint64)
	}

	if val, ok := m["BlockIOWriteBandwidth"]; ok {
		s.BlockIOWriteBandwidth = val.([][]interface{})
	}

	if val, ok := m["BusName"]; ok {
		s.BusName = val.(string)
	}

	if val, ok := m["CPUAccounting"]; ok {
		s.CPUAccounting = val.(bool)
	}

	if val, ok := m["CPUAffinity"]; ok {
		s.CPUAffinity = val.([]uint8)
	}

	if val, ok := m["CPUQuotaPerSecUSec"]; ok {
		s.CPUQuotaPerSecUSec = val.(uint64)
	}

	if val, ok := m["CPUSchedulingPolicy"]; ok {
		s.CPUSchedulingPolicy = val.(int32)
	}

	if val, ok := m["CPUSchedulingPriority"]; ok {
		s.CPUSchedulingPriority = val.(int32)
	}

	if val, ok := m["CPUSchedulingResetOnFork"]; ok {
		s.CPUSchedulingResetOnFork = val.(bool)
	}

	if val, ok := m["CPUShares"]; ok {
		s.CPUShares = val.(uint64)
	}

	if val, ok := m["CPUUsageNSec"]; ok {
		s.CPUUsageNSec = val.(uint64)
	}

	if val, ok := m["Capabilities"]; ok {
		s.Capabilities = val.(string)
	}

	if val, ok := m["CapabilityBoundingSet"]; ok {
		s.CapabilityBoundingSet = val.(uint64)
	}

	if val, ok := m["ControlGroup"]; ok {
		s.ControlGroup = val.(string)
	}

	if val, ok := m["ControlPID"]; ok {
		s.ControlPID = val.(uint32)
	}

	if val, ok := m["Delegate"]; ok {
		s.Delegate = val.(bool)
	}

	if val, ok := m["DeviceAllow"]; ok {
		s.DeviceAllow = val.([][]interface{})
	}

	if val, ok := m["DevicePolicy"]; ok {
		s.DevicePolicy = val.(string)
	}

	if val, ok := m["Environment"]; ok {
		s.Environment = val.([]string)
	}

	if val, ok := m["EnvironmentFiles"]; ok {
		s.EnvironmentFiles = val.([][]interface{})
	}

	if val, ok := m["ExecMainCode"]; ok {
		s.ExecMainCode = val.(int32)
	}

	if val, ok := m["ExecMainExitTimestamp"]; ok {
		s.ExecMainExitTimestamp = val.(uint64)
	}

	if val, ok := m["ExecMainExitTimestampMonotonic"]; ok {
		s.ExecMainExitTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["ExecMainPID"]; ok {
		s.ExecMainPID = val.(uint32)
	}

	if val, ok := m["ExecMainStartTimestamp"]; ok {
		s.ExecMainStartTimestamp = val.(uint64)
	}

	if val, ok := m["ExecMainStartTimestampMonotonic"]; ok {
		s.ExecMainStartTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["ExecMainStatus"]; ok {
		s.ExecMainStatus = val.(int32)
	}

	if val, ok := m["ExecReload"]; ok {
		s.ExecReload = val.([][]interface{})
	}

	if val, ok := m["ExecStart"]; ok {
		s.ExecStart = val.([][]interface{})
	}

	if val, ok := m["ExecStartPost"]; ok {
		s.ExecStartPost = val.([][]interface{})
	}

	if val, ok := m["ExecStartPre"]; ok {
		s.ExecStartPre = val.([][]interface{})
	}

	if val, ok := m["ExecStop"]; ok {
		s.ExecStop = val.([][]interface{})
	}

	if val, ok := m["ExecStopPost"]; ok {
		s.ExecStopPost = val.([][]interface{})
	}

	if val, ok := m["FailureAction"]; ok {
		s.FailureAction = val.(string)
	}

	if val, ok := m["FileDescriptorStoreMax"]; ok {
		s.FileDescriptorStoreMax = val.(uint32)
	}

	if val, ok := m["Group"]; ok {
		s.Group = val.(string)
	}

	if val, ok := m["GuessMainPID"]; ok {
		s.GuessMainPID = val.(bool)
	}

	if val, ok := m["IOScheduling"]; ok {
		s.IOScheduling = val.(int32)
	}

	if val, ok := m["IgnoreSIGPIPE"]; ok {
		s.IgnoreSIGPIPE = val.(bool)
	}

	if val, ok := m["InaccessibleDirectories"]; ok {
		s.InaccessibleDirectories = val.([]string)
	}

	if val, ok := m["KillMode"]; ok {
		s.KillMode = val.(string)
	}

	if val, ok := m["KillSignal"]; ok {
		s.KillSignal = val.(int32)
	}

	if val, ok := m["LimitAS"]; ok {
		s.LimitAS = val.(uint64)
	}

	if val, ok := m["LimitASSoft"]; ok {
		s.LimitASSoft = val.(uint64)
	}

	if val, ok := m["LimitCORE"]; ok {
		s.LimitCORE = val.(uint64)
	}

	if val, ok := m["LimitCORESoft"]; ok {
		s.LimitCORESoft = val.(uint64)
	}

	if val, ok := m["LimitCPU"]; ok {
		s.LimitCPU = val.(uint64)
	}

	if val, ok := m["LimitCPUSoft"]; ok {
		s.LimitCPUSoft = val.(uint64)
	}

	if val, ok := m["LimitDATA"]; ok {
		s.LimitDATA = val.(uint64)
	}

	if val, ok := m["LimitDATASoft"]; ok {
		s.LimitDATASoft = val.(uint64)
	}

	if val, ok := m["LimitFSIZE"]; ok {
		s.LimitFSIZE = val.(uint64)
	}

	if val, ok := m["LimitFSIZESoft"]; ok {
		s.LimitFSIZESoft = val.(uint64)
	}

	if val, ok := m["LimitLOCKS"]; ok {
		s.LimitLOCKS = val.(uint64)
	}

	if val, ok := m["LimitLOCKSSoft"]; ok {
		s.LimitLOCKSSoft = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCK"]; ok {
		s.LimitMEMLOCK = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCKSoft"]; ok {
		s.LimitMEMLOCKSoft = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUE"]; ok {
		s.LimitMSGQUEUE = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUESoft"]; ok {
		s.LimitMSGQUEUESoft = val.(uint64)
	}

	if val, ok := m["LimitNICE"]; ok {
		s.LimitNICE = val.(uint64)
	}

	if val, ok := m["LimitNICESoft"]; ok {
		s.LimitNICESoft = val.(uint64)
	}

	if val, ok := m["LimitNOFILE"]; ok {
		s.LimitNOFILE = val.(uint64)
	}

	if val, ok := m["LimitNOFILESoft"]; ok {
		s.LimitNOFILESoft = val.(uint64)
	}

	if val, ok := m["LimitNPROC"]; ok {
		s.LimitNPROC = val.(uint64)
	}

	if val, ok := m["LimitNPROCSoft"]; ok {
		s.LimitNPROCSoft = val.(uint64)
	}

	if val, ok := m["LimitRSS"]; ok {
		s.LimitRSS = val.(uint64)
	}

	if val, ok := m["LimitRSSSoft"]; ok {
		s.LimitRSSSoft = val.(uint64)
	}

	if val, ok := m["LimitRTPRIO"]; ok {
		s.LimitRTPRIO = val.(uint64)
	}

	if val, ok := m["LimitRTPRIOSoft"]; ok {
		s.LimitRTPRIOSoft = val.(uint64)
	}

	if val, ok := m["LimitRTTIME"]; ok {
		s.LimitRTTIME = val.(uint64)
	}

	if val, ok := m["LimitRTTIMESoft"]; ok {
		s.LimitRTTIMESoft = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDING"]; ok {
		s.LimitSIGPENDING = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDINGSoft"]; ok {
		s.LimitSIGPENDINGSoft = val.(uint64)
	}

	if val, ok := m["LimitSTACK"]; ok {
		s.LimitSTACK = val.(uint64)
	}

	if val, ok := m["LimitSTACKSoft"]; ok {
		s.LimitSTACKSoft = val.(uint64)
	}

	if val, ok := m["MainPID"]; ok {
		s.MainPID = val.(uint32)
	}

	if val, ok := m["MemoryAccounting"]; ok {
		s.MemoryAccounting = val.(bool)
	}

	if val, ok := m["MemoryCurrent"]; ok {
		s.MemoryCurrent = val.(uint64)
	}

	if val, ok := m["MemoryLimit"]; ok {
		s.MemoryLimit = val.(uint64)
	}

	if val, ok := m["MountFlags"]; ok {
		s.MountFlags = val.(uint64)
	}

	if val, ok := m["NFileDescriptorStore"]; ok {
		s.NFileDescriptorStore = val.(uint32)
	}

	if val, ok := m["Nice"]; ok {
		s.Nice = val.(int32)
	}

	if val, ok := m["NoNewPrivileges"]; ok {
		s.NoNewPrivileges = val.(bool)
	}

	if val, ok := m["NonBlocking"]; ok {
		s.NonBlocking = val.(bool)
	}

	if val, ok := m["NotifyAccess"]; ok {
		s.NotifyAccess = val.(string)
	}

	if val, ok := m["OOMScoreAdjust"]; ok {
		s.OOMScoreAdjust = val.(int32)
	}

	if val, ok := m["PAMName"]; ok {
		s.PAMName = val.(string)
	}

	if val, ok := m["PIDFile"]; ok {
		s.PIDFile = val.(string)
	}

	if val, ok := m["PassEnvironment"]; ok {
		s.PassEnvironment = val.([]string)
	}

	if val, ok := m["PermissionsStartOnly"]; ok {
		s.PermissionsStartOnly = val.(bool)
	}

	if val, ok := m["Personality"]; ok {
		s.Personality = val.(string)
	}

	if val, ok := m["PrivateDevices"]; ok {
		s.PrivateDevices = val.(bool)
	}

	if val, ok := m["PrivateNetwork"]; ok {
		s.PrivateNetwork = val.(bool)
	}

	if val, ok := m["PrivateTmp"]; ok {
		s.PrivateTmp = val.(bool)
	}

	if val, ok := m["ProtectHome"]; ok {
		s.ProtectHome = val.(string)
	}

	if val, ok := m["ProtectSystem"]; ok {
		s.ProtectSystem = val.(string)
	}

	if val, ok := m["ReadOnlyDirectories"]; ok {
		s.ReadOnlyDirectories = val.([]string)
	}

	if val, ok := m["ReadWriteDirectories"]; ok {
		s.ReadWriteDirectories = val.([]string)
	}

	if val, ok := m["RemainAfterExit"]; ok {
		s.RemainAfterExit = val.(bool)
	}

	if val, ok := m["Restart"]; ok {
		s.Restart = val.(string)
	}

	if val, ok := m["RestartUSec"]; ok {
		s.RestartUSec = val.(uint64)
	}

	if val, ok := m["RestrictAddressFamilies"]; ok {
		s.RestrictAddressFamilies = val.([]interface{})
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["RootDirectory"]; ok {
		s.RootDirectory = val.(string)
	}

	if val, ok := m["RootDirectoryStartOnly"]; ok {
		s.RootDirectoryStartOnly = val.(bool)
	}

	if val, ok := m["RuntimeDirectory"]; ok {
		s.RuntimeDirectory = val.([]string)
	}

	if val, ok := m["RuntimeDirectoryMode"]; ok {
		s.RuntimeDirectoryMode = val.(uint32)
	}

	if val, ok := m["RuntimeMaxUSec"]; ok {
		s.RuntimeMaxUSec = val.(uint64)
	}

	if val, ok := m["SELinuxContext"]; ok {
		s.SELinuxContext = val.([]interface{})
	}

	if val, ok := m["SameProcessGroup"]; ok {
		s.SameProcessGroup = val.(bool)
	}

	if val, ok := m["SecureBits"]; ok {
		s.SecureBits = val.(int32)
	}

	if val, ok := m["SendSIGHUP"]; ok {
		s.SendSIGHUP = val.(bool)
	}

	if val, ok := m["SendSIGKILL"]; ok {
		s.SendSIGKILL = val.(bool)
	}

	if val, ok := m["Slice"]; ok {
		s.Slice = val.(string)
	}

	if val, ok := m["SmackProcessLabel"]; ok {
		s.SmackProcessLabel = val.([]interface{})
	}

	if val, ok := m["StandardError"]; ok {
		s.StandardError = val.(string)
	}

	if val, ok := m["StandardInput"]; ok {
		s.StandardInput = val.(string)
	}

	if val, ok := m["StandardOutput"]; ok {
		s.StandardOutput = val.(string)
	}

	if val, ok := m["StartupBlockIOWeight"]; ok {
		s.StartupBlockIOWeight = val.(uint64)
	}

	if val, ok := m["StartupCPUShares"]; ok {
		s.StartupCPUShares = val.(uint64)
	}

	if val, ok := m["StatusErrno"]; ok {
		s.StatusErrno = val.(int32)
	}

	if val, ok := m["StatusText"]; ok {
		s.StatusText = val.(string)
	}

	if val, ok := m["SupplementaryGroups"]; ok {
		s.SupplementaryGroups = val.([]string)
	}

	if val, ok := m["SyslogFacility"]; ok {
		s.SyslogFacility = val.(int32)
	}

	if val, ok := m["SyslogIdentifier"]; ok {
		s.SyslogIdentifier = val.(string)
	}

	if val, ok := m["SyslogLevel"]; ok {
		s.SyslogLevel = val.(int32)
	}

	if val, ok := m["SyslogLevelPrefix"]; ok {
		s.SyslogLevelPrefix = val.(bool)
	}

	if val, ok := m["SyslogPriority"]; ok {
		s.SyslogPriority = val.(int32)
	}

	if val, ok := m["SystemCallArchitectures"]; ok {
		s.SystemCallArchitectures = val.([]string)
	}

	if val, ok := m["SystemCallErrorNumber"]; ok {
		s.SystemCallErrorNumber = val.(int32)
	}

	if val, ok := m["SystemCallFilter"]; ok {
		s.SystemCallFilter = val.([]interface{})
	}

	if val, ok := m["TTYPath"]; ok {
		s.TTYPath = val.(string)
	}

	if val, ok := m["TTYReset"]; ok {
		s.TTYReset = val.(bool)
	}

	if val, ok := m["TTYVHangup"]; ok {
		s.TTYVHangup = val.(bool)
	}

	if val, ok := m["TTYVTDisallocate"]; ok {
		s.TTYVTDisallocate = val.(bool)
	}

	if val, ok := m["TasksAccounting"]; ok {
		s.TasksAccounting = val.(bool)
	}

	if val, ok := m["TasksCurrent"]; ok {
		s.TasksCurrent = val.(uint64)
	}

	if val, ok := m["TasksMax"]; ok {
		s.TasksMax = val.(uint64)
	}

	if val, ok := m["TimeoutStartUSec"]; ok {
		s.TimeoutStartUSec = val.(uint64)
	}

	if val, ok := m["TimeoutStopUSec"]; ok {
		s.TimeoutStopUSec = val.(uint64)
	}

	if val, ok := m["TimerSlackNSec"]; ok {
		s.TimerSlackNSec = val.(uint64)
	}

	if val, ok := m["Type"]; ok {
		s.Type = val.(string)
	}

	if val, ok := m["UMask"]; ok {
		s.UMask = val.(uint32)
	}

	if val, ok := m["USBFunctionDescriptors"]; ok {
		s.USBFunctionDescriptors = val.(string)
	}

	if val, ok := m["USBFunctionStrings"]; ok {
		s.USBFunctionStrings = val.(string)
	}

	if val, ok := m["User"]; ok {
		s.User = val.(string)
	}

	if val, ok := m["UtmpIdentifier"]; ok {
		s.UtmpIdentifier = val.(string)
	}

	if val, ok := m["UtmpMode"]; ok {
		s.UtmpMode = val.(string)
	}

	if val, ok := m["WatchdogTimestamp"]; ok {
		s.WatchdogTimestamp = val.(uint64)
	}

	if val, ok := m["WatchdogTimestampMonotonic"]; ok {
		s.WatchdogTimestampMonotonic = val.(uint64)
	}

	if val, ok := m["WatchdogUSec"]; ok {
		s.WatchdogUSec = val.(uint64)
	}

	if val, ok := m["WorkingDirectory"]; ok {
		s.WorkingDirectory = val.(string)
	}
	return s
}

// SocketTypeProperties wraps the dbus api for system with properties from this unit type
type SocketTypeProperties struct {
	Accept                   bool            `export:"Accept"`
	AmbientCapabilities      uint64          `export:"AmbientCapabilities"`
	AppArmorProfile          []interface{}   `export:"AppArmorProfile"`
	Backlog                  uint32          `export:"Backlog"`
	BindIPv6Only             string          `export:"BindIPv6Only"`
	BindToDevice             string          `export:"BindToDevice"`
	BlockIOAccounting        bool            `export:"BlockIOAccounting"`
	BlockIODeviceWeight      [][]interface{} `export:"BlockIODeviceWeight"`
	BlockIOReadBandwidth     [][]interface{} `export:"BlockIOReadBandwidth"`
	BlockIOWeight            uint64          `export:"BlockIOWeight"`
	BlockIOWriteBandwidth    [][]interface{} `export:"BlockIOWriteBandwidth"`
	Broadcast                bool            `export:"Broadcast"`
	CPUAccounting            bool            `export:"CPUAccounting"`
	CPUAffinity              []uint8         `export:"CPUAffinity"`
	CPUQuotaPerSecUSec       uint64          `export:"CPUQuotaPerSecUSec"`
	CPUSchedulingPolicy      int32           `export:"CPUSchedulingPolicy"`
	CPUSchedulingPriority    int32           `export:"CPUSchedulingPriority"`
	CPUSchedulingResetOnFork bool            `export:"CPUSchedulingResetOnFork"`
	CPUShares                uint64          `export:"CPUShares"`
	CPUUsageNSec             uint64          `export:"CPUUsageNSec"`
	Capabilities             string          `export:"Capabilities"`
	CapabilityBoundingSet    uint64          `export:"CapabilityBoundingSet"`
	ControlGroup             string          `export:"ControlGroup"`
	ControlPID               uint32          `export:"ControlPID"`
	DeferAcceptUSec          uint64          `export:"DeferAcceptUSec"`
	Delegate                 bool            `export:"Delegate"`
	DeviceAllow              [][]interface{} `export:"DeviceAllow"`
	DevicePolicy             string          `export:"DevicePolicy"`
	DirectoryMode            uint32          `export:"DirectoryMode"`
	Environment              []string        `export:"Environment"`
	EnvironmentFiles         [][]interface{} `export:"EnvironmentFiles"`
	ExecStartPost            [][]interface{} `export:"ExecStartPost"`
	ExecStartPre             [][]interface{} `export:"ExecStartPre"`
	ExecStopPost             [][]interface{} `export:"ExecStopPost"`
	ExecStopPre              [][]interface{} `export:"ExecStopPre"`
	FileDescriptorName       string          `export:"FileDescriptorName"`
	FreeBind                 bool            `export:"FreeBind"`
	Group                    string          `export:"Group"`
	IOScheduling             int32           `export:"IOScheduling"`
	IPTOS                    int32           `export:"IPTOS"`
	IPTTL                    int32           `export:"IPTTL"`
	IgnoreSIGPIPE            bool            `export:"IgnoreSIGPIPE"`
	InaccessibleDirectories  []string        `export:"InaccessibleDirectories"`
	KeepAlive                bool            `export:"KeepAlive"`
	KeepAliveIntervalUSec    uint64          `export:"KeepAliveIntervalUSec"`
	KeepAliveProbes          uint32          `export:"KeepAliveProbes"`
	KeepAliveTimeUSec        uint64          `export:"KeepAliveTimeUSec"`
	KillMode                 string          `export:"KillMode"`
	KillSignal               int32           `export:"KillSignal"`
	LimitAS                  uint64          `export:"LimitAS"`
	LimitASSoft              uint64          `export:"LimitASSoft"`
	LimitCORE                uint64          `export:"LimitCORE"`
	LimitCORESoft            uint64          `export:"LimitCORESoft"`
	LimitCPU                 uint64          `export:"LimitCPU"`
	LimitCPUSoft             uint64          `export:"LimitCPUSoft"`
	LimitDATA                uint64          `export:"LimitDATA"`
	LimitDATASoft            uint64          `export:"LimitDATASoft"`
	LimitFSIZE               uint64          `export:"LimitFSIZE"`
	LimitFSIZESoft           uint64          `export:"LimitFSIZESoft"`
	LimitLOCKS               uint64          `export:"LimitLOCKS"`
	LimitLOCKSSoft           uint64          `export:"LimitLOCKSSoft"`
	LimitMEMLOCK             uint64          `export:"LimitMEMLOCK"`
	LimitMEMLOCKSoft         uint64          `export:"LimitMEMLOCKSoft"`
	LimitMSGQUEUE            uint64          `export:"LimitMSGQUEUE"`
	LimitMSGQUEUESoft        uint64          `export:"LimitMSGQUEUESoft"`
	LimitNICE                uint64          `export:"LimitNICE"`
	LimitNICESoft            uint64          `export:"LimitNICESoft"`
	LimitNOFILE              uint64          `export:"LimitNOFILE"`
	LimitNOFILESoft          uint64          `export:"LimitNOFILESoft"`
	LimitNPROC               uint64          `export:"LimitNPROC"`
	LimitNPROCSoft           uint64          `export:"LimitNPROCSoft"`
	LimitRSS                 uint64          `export:"LimitRSS"`
	LimitRSSSoft             uint64          `export:"LimitRSSSoft"`
	LimitRTPRIO              uint64          `export:"LimitRTPRIO"`
	LimitRTPRIOSoft          uint64          `export:"LimitRTPRIOSoft"`
	LimitRTTIME              uint64          `export:"LimitRTTIME"`
	LimitRTTIMESoft          uint64          `export:"LimitRTTIMESoft"`
	LimitSIGPENDING          uint64          `export:"LimitSIGPENDING"`
	LimitSIGPENDINGSoft      uint64          `export:"LimitSIGPENDINGSoft"`
	LimitSTACK               uint64          `export:"LimitSTACK"`
	LimitSTACKSoft           uint64          `export:"LimitSTACKSoft"`
	Listen                   [][]interface{} `export:"Listen"`
	Mark                     int32           `export:"Mark"`
	MaxConnections           uint32          `export:"MaxConnections"`
	MemoryAccounting         bool            `export:"MemoryAccounting"`
	MemoryCurrent            uint64          `export:"MemoryCurrent"`
	MemoryLimit              uint64          `export:"MemoryLimit"`
	MessageQueueMaxMessages  int64           `export:"MessageQueueMaxMessages"`
	MessageQueueMessageSize  int64           `export:"MessageQueueMessageSize"`
	MountFlags               uint64          `export:"MountFlags"`
	NAccepted                uint32          `export:"NAccepted"`
	NConnections             uint32          `export:"NConnections"`
	Nice                     int32           `export:"Nice"`
	NoDelay                  bool            `export:"NoDelay"`
	NoNewPrivileges          bool            `export:"NoNewPrivileges"`
	NonBlocking              bool            `export:"NonBlocking"`
	OOMScoreAdjust           int32           `export:"OOMScoreAdjust"`
	PAMName                  string          `export:"PAMName"`
	PassCredentials          bool            `export:"PassCredentials"`
	PassEnvironment          []string        `export:"PassEnvironment"`
	PassSecurity             bool            `export:"PassSecurity"`
	Personality              string          `export:"Personality"`
	PipeSize                 uint64          `export:"PipeSize"`
	Priority                 int32           `export:"Priority"`
	PrivateDevices           bool            `export:"PrivateDevices"`
	PrivateNetwork           bool            `export:"PrivateNetwork"`
	PrivateTmp               bool            `export:"PrivateTmp"`
	ProtectHome              string          `export:"ProtectHome"`
	ProtectSystem            string          `export:"ProtectSystem"`
	ReadOnlyDirectories      []string        `export:"ReadOnlyDirectories"`
	ReadWriteDirectories     []string        `export:"ReadWriteDirectories"`
	ReceiveBuffer            uint64          `export:"ReceiveBuffer"`
	RemoveOnStop             bool            `export:"RemoveOnStop"`
	RestrictAddressFamilies  []interface{}   `export:"RestrictAddressFamilies"`
	Result                   string          `export:"Result"`
	ReusePort                bool            `export:"ReusePort"`
	RootDirectory            string          `export:"RootDirectory"`
	RuntimeDirectory         []string        `export:"RuntimeDirectory"`
	RuntimeDirectoryMode     uint32          `export:"RuntimeDirectoryMode"`
	SELinuxContext           []interface{}   `export:"SELinuxContext"`
	SameProcessGroup         bool            `export:"SameProcessGroup"`
	SecureBits               int32           `export:"SecureBits"`
	SendBuffer               uint64          `export:"SendBuffer"`
	SendSIGHUP               bool            `export:"SendSIGHUP"`
	SendSIGKILL              bool            `export:"SendSIGKILL"`
	Slice                    string          `export:"Slice"`
	SmackLabel               string          `export:"SmackLabel"`
	SmackLabelIPIn           string          `export:"SmackLabelIPIn"`
	SmackLabelIPOut          string          `export:"SmackLabelIPOut"`
	SmackProcessLabel        []interface{}   `export:"SmackProcessLabel"`
	SocketGroup              string          `export:"SocketGroup"`
	SocketMode               uint32          `export:"SocketMode"`
	SocketProtocol           int32           `export:"SocketProtocol"`
	SocketUser               string          `export:"SocketUser"`
	StandardError            string          `export:"StandardError"`
	StandardInput            string          `export:"StandardInput"`
	StandardOutput           string          `export:"StandardOutput"`
	StartupBlockIOWeight     uint64          `export:"StartupBlockIOWeight"`
	StartupCPUShares         uint64          `export:"StartupCPUShares"`
	SupplementaryGroups      []string        `export:"SupplementaryGroups"`
	Symlinks                 []string        `export:"Symlinks"`
	SyslogFacility           int32           `export:"SyslogFacility"`
	SyslogIdentifier         string          `export:"SyslogIdentifier"`
	SyslogLevel              int32           `export:"SyslogLevel"`
	SyslogLevelPrefix        bool            `export:"SyslogLevelPrefix"`
	SyslogPriority           int32           `export:"SyslogPriority"`
	SystemCallArchitectures  []string        `export:"SystemCallArchitectures"`
	SystemCallErrorNumber    int32           `export:"SystemCallErrorNumber"`
	SystemCallFilter         []interface{}   `export:"SystemCallFilter"`
	TTYPath                  string          `export:"TTYPath"`
	TTYReset                 bool            `export:"TTYReset"`
	TTYVHangup               bool            `export:"TTYVHangup"`
	TTYVTDisallocate         bool            `export:"TTYVTDisallocate"`
	TasksAccounting          bool            `export:"TasksAccounting"`
	TasksCurrent             uint64          `export:"TasksCurrent"`
	TasksMax                 uint64          `export:"TasksMax"`
	TimeoutUSec              uint64          `export:"TimeoutUSec"`
	TimerSlackNSec           uint64          `export:"TimerSlackNSec"`
	Transparent              bool            `export:"Transparent"`
	TriggerLimitBurst        uint32          `export:"TriggerLimitBurst"`
	TriggerLimitIntervalSec  uint64          `export:"TriggerLimitIntervalSec"`
	UMask                    uint32          `export:"UMask"`
	User                     string          `export:"User"`
	UtmpIdentifier           string          `export:"UtmpIdentifier"`
	UtmpMode                 string          `export:"UtmpMode"`
	WorkingDirectory         string          `export:"WorkingDirectory"`
	Writable                 bool            `export:"Writable"`
}

// newSocketTypePropertiesFromMap generates a new SocketTypeProperties given a systemd property map
func newSocketTypePropertiesFromMap(m map[string]interface{}) *SocketTypeProperties {
	s := &SocketTypeProperties{}

	if val, ok := m["Accept"]; ok {
		s.Accept = val.(bool)
	}

	if val, ok := m["AmbientCapabilities"]; ok {
		s.AmbientCapabilities = val.(uint64)
	}

	if val, ok := m["AppArmorProfile"]; ok {
		s.AppArmorProfile = val.([]interface{})
	}

	if val, ok := m["Backlog"]; ok {
		s.Backlog = val.(uint32)
	}

	if val, ok := m["BindIPv6Only"]; ok {
		s.BindIPv6Only = val.(string)
	}

	if val, ok := m["BindToDevice"]; ok {
		s.BindToDevice = val.(string)
	}

	if val, ok := m["BlockIOAccounting"]; ok {
		s.BlockIOAccounting = val.(bool)
	}

	if val, ok := m["BlockIODeviceWeight"]; ok {
		s.BlockIODeviceWeight = val.([][]interface{})
	}

	if val, ok := m["BlockIOReadBandwidth"]; ok {
		s.BlockIOReadBandwidth = val.([][]interface{})
	}

	if val, ok := m["BlockIOWeight"]; ok {
		s.BlockIOWeight = val.(uint64)
	}

	if val, ok := m["BlockIOWriteBandwidth"]; ok {
		s.BlockIOWriteBandwidth = val.([][]interface{})
	}

	if val, ok := m["Broadcast"]; ok {
		s.Broadcast = val.(bool)
	}

	if val, ok := m["CPUAccounting"]; ok {
		s.CPUAccounting = val.(bool)
	}

	if val, ok := m["CPUAffinity"]; ok {
		s.CPUAffinity = val.([]uint8)
	}

	if val, ok := m["CPUQuotaPerSecUSec"]; ok {
		s.CPUQuotaPerSecUSec = val.(uint64)
	}

	if val, ok := m["CPUSchedulingPolicy"]; ok {
		s.CPUSchedulingPolicy = val.(int32)
	}

	if val, ok := m["CPUSchedulingPriority"]; ok {
		s.CPUSchedulingPriority = val.(int32)
	}

	if val, ok := m["CPUSchedulingResetOnFork"]; ok {
		s.CPUSchedulingResetOnFork = val.(bool)
	}

	if val, ok := m["CPUShares"]; ok {
		s.CPUShares = val.(uint64)
	}

	if val, ok := m["CPUUsageNSec"]; ok {
		s.CPUUsageNSec = val.(uint64)
	}

	if val, ok := m["Capabilities"]; ok {
		s.Capabilities = val.(string)
	}

	if val, ok := m["CapabilityBoundingSet"]; ok {
		s.CapabilityBoundingSet = val.(uint64)
	}

	if val, ok := m["ControlGroup"]; ok {
		s.ControlGroup = val.(string)
	}

	if val, ok := m["ControlPID"]; ok {
		s.ControlPID = val.(uint32)
	}

	if val, ok := m["DeferAcceptUSec"]; ok {
		s.DeferAcceptUSec = val.(uint64)
	}

	if val, ok := m["Delegate"]; ok {
		s.Delegate = val.(bool)
	}

	if val, ok := m["DeviceAllow"]; ok {
		s.DeviceAllow = val.([][]interface{})
	}

	if val, ok := m["DevicePolicy"]; ok {
		s.DevicePolicy = val.(string)
	}

	if val, ok := m["DirectoryMode"]; ok {
		s.DirectoryMode = val.(uint32)
	}

	if val, ok := m["Environment"]; ok {
		s.Environment = val.([]string)
	}

	if val, ok := m["EnvironmentFiles"]; ok {
		s.EnvironmentFiles = val.([][]interface{})
	}

	if val, ok := m["ExecStartPost"]; ok {
		s.ExecStartPost = val.([][]interface{})
	}

	if val, ok := m["ExecStartPre"]; ok {
		s.ExecStartPre = val.([][]interface{})
	}

	if val, ok := m["ExecStopPost"]; ok {
		s.ExecStopPost = val.([][]interface{})
	}

	if val, ok := m["ExecStopPre"]; ok {
		s.ExecStopPre = val.([][]interface{})
	}

	if val, ok := m["FileDescriptorName"]; ok {
		s.FileDescriptorName = val.(string)
	}

	if val, ok := m["FreeBind"]; ok {
		s.FreeBind = val.(bool)
	}

	if val, ok := m["Group"]; ok {
		s.Group = val.(string)
	}

	if val, ok := m["IOScheduling"]; ok {
		s.IOScheduling = val.(int32)
	}

	if val, ok := m["IPTOS"]; ok {
		s.IPTOS = val.(int32)
	}

	if val, ok := m["IPTTL"]; ok {
		s.IPTTL = val.(int32)
	}

	if val, ok := m["IgnoreSIGPIPE"]; ok {
		s.IgnoreSIGPIPE = val.(bool)
	}

	if val, ok := m["InaccessibleDirectories"]; ok {
		s.InaccessibleDirectories = val.([]string)
	}

	if val, ok := m["KeepAlive"]; ok {
		s.KeepAlive = val.(bool)
	}

	if val, ok := m["KeepAliveIntervalUSec"]; ok {
		s.KeepAliveIntervalUSec = val.(uint64)
	}

	if val, ok := m["KeepAliveProbes"]; ok {
		s.KeepAliveProbes = val.(uint32)
	}

	if val, ok := m["KeepAliveTimeUSec"]; ok {
		s.KeepAliveTimeUSec = val.(uint64)
	}

	if val, ok := m["KillMode"]; ok {
		s.KillMode = val.(string)
	}

	if val, ok := m["KillSignal"]; ok {
		s.KillSignal = val.(int32)
	}

	if val, ok := m["LimitAS"]; ok {
		s.LimitAS = val.(uint64)
	}

	if val, ok := m["LimitASSoft"]; ok {
		s.LimitASSoft = val.(uint64)
	}

	if val, ok := m["LimitCORE"]; ok {
		s.LimitCORE = val.(uint64)
	}

	if val, ok := m["LimitCORESoft"]; ok {
		s.LimitCORESoft = val.(uint64)
	}

	if val, ok := m["LimitCPU"]; ok {
		s.LimitCPU = val.(uint64)
	}

	if val, ok := m["LimitCPUSoft"]; ok {
		s.LimitCPUSoft = val.(uint64)
	}

	if val, ok := m["LimitDATA"]; ok {
		s.LimitDATA = val.(uint64)
	}

	if val, ok := m["LimitDATASoft"]; ok {
		s.LimitDATASoft = val.(uint64)
	}

	if val, ok := m["LimitFSIZE"]; ok {
		s.LimitFSIZE = val.(uint64)
	}

	if val, ok := m["LimitFSIZESoft"]; ok {
		s.LimitFSIZESoft = val.(uint64)
	}

	if val, ok := m["LimitLOCKS"]; ok {
		s.LimitLOCKS = val.(uint64)
	}

	if val, ok := m["LimitLOCKSSoft"]; ok {
		s.LimitLOCKSSoft = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCK"]; ok {
		s.LimitMEMLOCK = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCKSoft"]; ok {
		s.LimitMEMLOCKSoft = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUE"]; ok {
		s.LimitMSGQUEUE = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUESoft"]; ok {
		s.LimitMSGQUEUESoft = val.(uint64)
	}

	if val, ok := m["LimitNICE"]; ok {
		s.LimitNICE = val.(uint64)
	}

	if val, ok := m["LimitNICESoft"]; ok {
		s.LimitNICESoft = val.(uint64)
	}

	if val, ok := m["LimitNOFILE"]; ok {
		s.LimitNOFILE = val.(uint64)
	}

	if val, ok := m["LimitNOFILESoft"]; ok {
		s.LimitNOFILESoft = val.(uint64)
	}

	if val, ok := m["LimitNPROC"]; ok {
		s.LimitNPROC = val.(uint64)
	}

	if val, ok := m["LimitNPROCSoft"]; ok {
		s.LimitNPROCSoft = val.(uint64)
	}

	if val, ok := m["LimitRSS"]; ok {
		s.LimitRSS = val.(uint64)
	}

	if val, ok := m["LimitRSSSoft"]; ok {
		s.LimitRSSSoft = val.(uint64)
	}

	if val, ok := m["LimitRTPRIO"]; ok {
		s.LimitRTPRIO = val.(uint64)
	}

	if val, ok := m["LimitRTPRIOSoft"]; ok {
		s.LimitRTPRIOSoft = val.(uint64)
	}

	if val, ok := m["LimitRTTIME"]; ok {
		s.LimitRTTIME = val.(uint64)
	}

	if val, ok := m["LimitRTTIMESoft"]; ok {
		s.LimitRTTIMESoft = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDING"]; ok {
		s.LimitSIGPENDING = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDINGSoft"]; ok {
		s.LimitSIGPENDINGSoft = val.(uint64)
	}

	if val, ok := m["LimitSTACK"]; ok {
		s.LimitSTACK = val.(uint64)
	}

	if val, ok := m["LimitSTACKSoft"]; ok {
		s.LimitSTACKSoft = val.(uint64)
	}

	if val, ok := m["Listen"]; ok {
		s.Listen = val.([][]interface{})
	}

	if val, ok := m["Mark"]; ok {
		s.Mark = val.(int32)
	}

	if val, ok := m["MaxConnections"]; ok {
		s.MaxConnections = val.(uint32)
	}

	if val, ok := m["MemoryAccounting"]; ok {
		s.MemoryAccounting = val.(bool)
	}

	if val, ok := m["MemoryCurrent"]; ok {
		s.MemoryCurrent = val.(uint64)
	}

	if val, ok := m["MemoryLimit"]; ok {
		s.MemoryLimit = val.(uint64)
	}

	if val, ok := m["MessageQueueMaxMessages"]; ok {
		s.MessageQueueMaxMessages = val.(int64)
	}

	if val, ok := m["MessageQueueMessageSize"]; ok {
		s.MessageQueueMessageSize = val.(int64)
	}

	if val, ok := m["MountFlags"]; ok {
		s.MountFlags = val.(uint64)
	}

	if val, ok := m["NAccepted"]; ok {
		s.NAccepted = val.(uint32)
	}

	if val, ok := m["NConnections"]; ok {
		s.NConnections = val.(uint32)
	}

	if val, ok := m["Nice"]; ok {
		s.Nice = val.(int32)
	}

	if val, ok := m["NoDelay"]; ok {
		s.NoDelay = val.(bool)
	}

	if val, ok := m["NoNewPrivileges"]; ok {
		s.NoNewPrivileges = val.(bool)
	}

	if val, ok := m["NonBlocking"]; ok {
		s.NonBlocking = val.(bool)
	}

	if val, ok := m["OOMScoreAdjust"]; ok {
		s.OOMScoreAdjust = val.(int32)
	}

	if val, ok := m["PAMName"]; ok {
		s.PAMName = val.(string)
	}

	if val, ok := m["PassCredentials"]; ok {
		s.PassCredentials = val.(bool)
	}

	if val, ok := m["PassEnvironment"]; ok {
		s.PassEnvironment = val.([]string)
	}

	if val, ok := m["PassSecurity"]; ok {
		s.PassSecurity = val.(bool)
	}

	if val, ok := m["Personality"]; ok {
		s.Personality = val.(string)
	}

	if val, ok := m["PipeSize"]; ok {
		s.PipeSize = val.(uint64)
	}

	if val, ok := m["Priority"]; ok {
		s.Priority = val.(int32)
	}

	if val, ok := m["PrivateDevices"]; ok {
		s.PrivateDevices = val.(bool)
	}

	if val, ok := m["PrivateNetwork"]; ok {
		s.PrivateNetwork = val.(bool)
	}

	if val, ok := m["PrivateTmp"]; ok {
		s.PrivateTmp = val.(bool)
	}

	if val, ok := m["ProtectHome"]; ok {
		s.ProtectHome = val.(string)
	}

	if val, ok := m["ProtectSystem"]; ok {
		s.ProtectSystem = val.(string)
	}

	if val, ok := m["ReadOnlyDirectories"]; ok {
		s.ReadOnlyDirectories = val.([]string)
	}

	if val, ok := m["ReadWriteDirectories"]; ok {
		s.ReadWriteDirectories = val.([]string)
	}

	if val, ok := m["ReceiveBuffer"]; ok {
		s.ReceiveBuffer = val.(uint64)
	}

	if val, ok := m["RemoveOnStop"]; ok {
		s.RemoveOnStop = val.(bool)
	}

	if val, ok := m["RestrictAddressFamilies"]; ok {
		s.RestrictAddressFamilies = val.([]interface{})
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["ReusePort"]; ok {
		s.ReusePort = val.(bool)
	}

	if val, ok := m["RootDirectory"]; ok {
		s.RootDirectory = val.(string)
	}

	if val, ok := m["RuntimeDirectory"]; ok {
		s.RuntimeDirectory = val.([]string)
	}

	if val, ok := m["RuntimeDirectoryMode"]; ok {
		s.RuntimeDirectoryMode = val.(uint32)
	}

	if val, ok := m["SELinuxContext"]; ok {
		s.SELinuxContext = val.([]interface{})
	}

	if val, ok := m["SameProcessGroup"]; ok {
		s.SameProcessGroup = val.(bool)
	}

	if val, ok := m["SecureBits"]; ok {
		s.SecureBits = val.(int32)
	}

	if val, ok := m["SendBuffer"]; ok {
		s.SendBuffer = val.(uint64)
	}

	if val, ok := m["SendSIGHUP"]; ok {
		s.SendSIGHUP = val.(bool)
	}

	if val, ok := m["SendSIGKILL"]; ok {
		s.SendSIGKILL = val.(bool)
	}

	if val, ok := m["Slice"]; ok {
		s.Slice = val.(string)
	}

	if val, ok := m["SmackLabel"]; ok {
		s.SmackLabel = val.(string)
	}

	if val, ok := m["SmackLabelIPIn"]; ok {
		s.SmackLabelIPIn = val.(string)
	}

	if val, ok := m["SmackLabelIPOut"]; ok {
		s.SmackLabelIPOut = val.(string)
	}

	if val, ok := m["SmackProcessLabel"]; ok {
		s.SmackProcessLabel = val.([]interface{})
	}

	if val, ok := m["SocketGroup"]; ok {
		s.SocketGroup = val.(string)
	}

	if val, ok := m["SocketMode"]; ok {
		s.SocketMode = val.(uint32)
	}

	if val, ok := m["SocketProtocol"]; ok {
		s.SocketProtocol = val.(int32)
	}

	if val, ok := m["SocketUser"]; ok {
		s.SocketUser = val.(string)
	}

	if val, ok := m["StandardError"]; ok {
		s.StandardError = val.(string)
	}

	if val, ok := m["StandardInput"]; ok {
		s.StandardInput = val.(string)
	}

	if val, ok := m["StandardOutput"]; ok {
		s.StandardOutput = val.(string)
	}

	if val, ok := m["StartupBlockIOWeight"]; ok {
		s.StartupBlockIOWeight = val.(uint64)
	}

	if val, ok := m["StartupCPUShares"]; ok {
		s.StartupCPUShares = val.(uint64)
	}

	if val, ok := m["SupplementaryGroups"]; ok {
		s.SupplementaryGroups = val.([]string)
	}

	if val, ok := m["Symlinks"]; ok {
		s.Symlinks = val.([]string)
	}

	if val, ok := m["SyslogFacility"]; ok {
		s.SyslogFacility = val.(int32)
	}

	if val, ok := m["SyslogIdentifier"]; ok {
		s.SyslogIdentifier = val.(string)
	}

	if val, ok := m["SyslogLevel"]; ok {
		s.SyslogLevel = val.(int32)
	}

	if val, ok := m["SyslogLevelPrefix"]; ok {
		s.SyslogLevelPrefix = val.(bool)
	}

	if val, ok := m["SyslogPriority"]; ok {
		s.SyslogPriority = val.(int32)
	}

	if val, ok := m["SystemCallArchitectures"]; ok {
		s.SystemCallArchitectures = val.([]string)
	}

	if val, ok := m["SystemCallErrorNumber"]; ok {
		s.SystemCallErrorNumber = val.(int32)
	}

	if val, ok := m["SystemCallFilter"]; ok {
		s.SystemCallFilter = val.([]interface{})
	}

	if val, ok := m["TTYPath"]; ok {
		s.TTYPath = val.(string)
	}

	if val, ok := m["TTYReset"]; ok {
		s.TTYReset = val.(bool)
	}

	if val, ok := m["TTYVHangup"]; ok {
		s.TTYVHangup = val.(bool)
	}

	if val, ok := m["TTYVTDisallocate"]; ok {
		s.TTYVTDisallocate = val.(bool)
	}

	if val, ok := m["TasksAccounting"]; ok {
		s.TasksAccounting = val.(bool)
	}

	if val, ok := m["TasksCurrent"]; ok {
		s.TasksCurrent = val.(uint64)
	}

	if val, ok := m["TasksMax"]; ok {
		s.TasksMax = val.(uint64)
	}

	if val, ok := m["TimeoutUSec"]; ok {
		s.TimeoutUSec = val.(uint64)
	}

	if val, ok := m["TimerSlackNSec"]; ok {
		s.TimerSlackNSec = val.(uint64)
	}

	if val, ok := m["Transparent"]; ok {
		s.Transparent = val.(bool)
	}

	if val, ok := m["TriggerLimitBurst"]; ok {
		s.TriggerLimitBurst = val.(uint32)
	}

	if val, ok := m["TriggerLimitIntervalSec"]; ok {
		s.TriggerLimitIntervalSec = val.(uint64)
	}

	if val, ok := m["UMask"]; ok {
		s.UMask = val.(uint32)
	}

	if val, ok := m["User"]; ok {
		s.User = val.(string)
	}

	if val, ok := m["UtmpIdentifier"]; ok {
		s.UtmpIdentifier = val.(string)
	}

	if val, ok := m["UtmpMode"]; ok {
		s.UtmpMode = val.(string)
	}

	if val, ok := m["WorkingDirectory"]; ok {
		s.WorkingDirectory = val.(string)
	}

	if val, ok := m["Writable"]; ok {
		s.Writable = val.(bool)
	}
	return s
}

// DeviceTypeProperties wraps the dbus api for system with properties from this unit type
type DeviceTypeProperties struct {
	SysFSPath string `export:"SysFSPath"`
}

// newDeviceTypePropertiesFromMap generates a new DeviceTypeProperties given a systemd property map
func newDeviceTypePropertiesFromMap(m map[string]interface{}) *DeviceTypeProperties {
	s := &DeviceTypeProperties{}

	if val, ok := m["SysFSPath"]; ok {
		s.SysFSPath = val.(string)
	}
	return s
}

// MountTypeProperties wraps the dbus api for system with properties from this unit type
type MountTypeProperties struct {
	AmbientCapabilities      uint64          `export:"AmbientCapabilities"`
	AppArmorProfile          []interface{}   `export:"AppArmorProfile"`
	BlockIOAccounting        bool            `export:"BlockIOAccounting"`
	BlockIODeviceWeight      [][]interface{} `export:"BlockIODeviceWeight"`
	BlockIOReadBandwidth     [][]interface{} `export:"BlockIOReadBandwidth"`
	BlockIOWeight            uint64          `export:"BlockIOWeight"`
	BlockIOWriteBandwidth    [][]interface{} `export:"BlockIOWriteBandwidth"`
	CPUAccounting            bool            `export:"CPUAccounting"`
	CPUAffinity              []uint8         `export:"CPUAffinity"`
	CPUQuotaPerSecUSec       uint64          `export:"CPUQuotaPerSecUSec"`
	CPUSchedulingPolicy      int32           `export:"CPUSchedulingPolicy"`
	CPUSchedulingPriority    int32           `export:"CPUSchedulingPriority"`
	CPUSchedulingResetOnFork bool            `export:"CPUSchedulingResetOnFork"`
	CPUShares                uint64          `export:"CPUShares"`
	CPUUsageNSec             uint64          `export:"CPUUsageNSec"`
	Capabilities             string          `export:"Capabilities"`
	CapabilityBoundingSet    uint64          `export:"CapabilityBoundingSet"`
	ControlGroup             string          `export:"ControlGroup"`
	ControlPID               uint32          `export:"ControlPID"`
	Delegate                 bool            `export:"Delegate"`
	DeviceAllow              [][]interface{} `export:"DeviceAllow"`
	DevicePolicy             string          `export:"DevicePolicy"`
	DirectoryMode            uint32          `export:"DirectoryMode"`
	Environment              []string        `export:"Environment"`
	EnvironmentFiles         [][]interface{} `export:"EnvironmentFiles"`
	ExecMount                [][]interface{} `export:"ExecMount"`
	ExecRemount              [][]interface{} `export:"ExecRemount"`
	ExecUnmount              [][]interface{} `export:"ExecUnmount"`
	Group                    string          `export:"Group"`
	IOScheduling             int32           `export:"IOScheduling"`
	IgnoreSIGPIPE            bool            `export:"IgnoreSIGPIPE"`
	InaccessibleDirectories  []string        `export:"InaccessibleDirectories"`
	KillMode                 string          `export:"KillMode"`
	KillSignal               int32           `export:"KillSignal"`
	LimitAS                  uint64          `export:"LimitAS"`
	LimitASSoft              uint64          `export:"LimitASSoft"`
	LimitCORE                uint64          `export:"LimitCORE"`
	LimitCORESoft            uint64          `export:"LimitCORESoft"`
	LimitCPU                 uint64          `export:"LimitCPU"`
	LimitCPUSoft             uint64          `export:"LimitCPUSoft"`
	LimitDATA                uint64          `export:"LimitDATA"`
	LimitDATASoft            uint64          `export:"LimitDATASoft"`
	LimitFSIZE               uint64          `export:"LimitFSIZE"`
	LimitFSIZESoft           uint64          `export:"LimitFSIZESoft"`
	LimitLOCKS               uint64          `export:"LimitLOCKS"`
	LimitLOCKSSoft           uint64          `export:"LimitLOCKSSoft"`
	LimitMEMLOCK             uint64          `export:"LimitMEMLOCK"`
	LimitMEMLOCKSoft         uint64          `export:"LimitMEMLOCKSoft"`
	LimitMSGQUEUE            uint64          `export:"LimitMSGQUEUE"`
	LimitMSGQUEUESoft        uint64          `export:"LimitMSGQUEUESoft"`
	LimitNICE                uint64          `export:"LimitNICE"`
	LimitNICESoft            uint64          `export:"LimitNICESoft"`
	LimitNOFILE              uint64          `export:"LimitNOFILE"`
	LimitNOFILESoft          uint64          `export:"LimitNOFILESoft"`
	LimitNPROC               uint64          `export:"LimitNPROC"`
	LimitNPROCSoft           uint64          `export:"LimitNPROCSoft"`
	LimitRSS                 uint64          `export:"LimitRSS"`
	LimitRSSSoft             uint64          `export:"LimitRSSSoft"`
	LimitRTPRIO              uint64          `export:"LimitRTPRIO"`
	LimitRTPRIOSoft          uint64          `export:"LimitRTPRIOSoft"`
	LimitRTTIME              uint64          `export:"LimitRTTIME"`
	LimitRTTIMESoft          uint64          `export:"LimitRTTIMESoft"`
	LimitSIGPENDING          uint64          `export:"LimitSIGPENDING"`
	LimitSIGPENDINGSoft      uint64          `export:"LimitSIGPENDINGSoft"`
	LimitSTACK               uint64          `export:"LimitSTACK"`
	LimitSTACKSoft           uint64          `export:"LimitSTACKSoft"`
	MemoryAccounting         bool            `export:"MemoryAccounting"`
	MemoryCurrent            uint64          `export:"MemoryCurrent"`
	MemoryLimit              uint64          `export:"MemoryLimit"`
	MountFlags               uint64          `export:"MountFlags"`
	Nice                     int32           `export:"Nice"`
	NoNewPrivileges          bool            `export:"NoNewPrivileges"`
	NonBlocking              bool            `export:"NonBlocking"`
	OOMScoreAdjust           int32           `export:"OOMScoreAdjust"`
	Options                  string          `export:"Options"`
	PAMName                  string          `export:"PAMName"`
	PassEnvironment          []string        `export:"PassEnvironment"`
	Personality              string          `export:"Personality"`
	PrivateDevices           bool            `export:"PrivateDevices"`
	PrivateNetwork           bool            `export:"PrivateNetwork"`
	PrivateTmp               bool            `export:"PrivateTmp"`
	ProtectHome              string          `export:"ProtectHome"`
	ProtectSystem            string          `export:"ProtectSystem"`
	ReadOnlyDirectories      []string        `export:"ReadOnlyDirectories"`
	ReadWriteDirectories     []string        `export:"ReadWriteDirectories"`
	RestrictAddressFamilies  []interface{}   `export:"RestrictAddressFamilies"`
	Result                   string          `export:"Result"`
	RootDirectory            string          `export:"RootDirectory"`
	RuntimeDirectory         []string        `export:"RuntimeDirectory"`
	RuntimeDirectoryMode     uint32          `export:"RuntimeDirectoryMode"`
	SELinuxContext           []interface{}   `export:"SELinuxContext"`
	SameProcessGroup         bool            `export:"SameProcessGroup"`
	SecureBits               int32           `export:"SecureBits"`
	SendSIGHUP               bool            `export:"SendSIGHUP"`
	SendSIGKILL              bool            `export:"SendSIGKILL"`
	Slice                    string          `export:"Slice"`
	SloppyOptions            bool            `export:"SloppyOptions"`
	SmackProcessLabel        []interface{}   `export:"SmackProcessLabel"`
	StandardError            string          `export:"StandardError"`
	StandardInput            string          `export:"StandardInput"`
	StandardOutput           string          `export:"StandardOutput"`
	StartupBlockIOWeight     uint64          `export:"StartupBlockIOWeight"`
	StartupCPUShares         uint64          `export:"StartupCPUShares"`
	SupplementaryGroups      []string        `export:"SupplementaryGroups"`
	SyslogFacility           int32           `export:"SyslogFacility"`
	SyslogIdentifier         string          `export:"SyslogIdentifier"`
	SyslogLevel              int32           `export:"SyslogLevel"`
	SyslogLevelPrefix        bool            `export:"SyslogLevelPrefix"`
	SyslogPriority           int32           `export:"SyslogPriority"`
	SystemCallArchitectures  []string        `export:"SystemCallArchitectures"`
	SystemCallErrorNumber    int32           `export:"SystemCallErrorNumber"`
	SystemCallFilter         []interface{}   `export:"SystemCallFilter"`
	TTYPath                  string          `export:"TTYPath"`
	TTYReset                 bool            `export:"TTYReset"`
	TTYVHangup               bool            `export:"TTYVHangup"`
	TTYVTDisallocate         bool            `export:"TTYVTDisallocate"`
	TasksAccounting          bool            `export:"TasksAccounting"`
	TasksCurrent             uint64          `export:"TasksCurrent"`
	TasksMax                 uint64          `export:"TasksMax"`
	TimeoutUSec              uint64          `export:"TimeoutUSec"`
	TimerSlackNSec           uint64          `export:"TimerSlackNSec"`
	Type                     string          `export:"Type"`
	UMask                    uint32          `export:"UMask"`
	User                     string          `export:"User"`
	UtmpIdentifier           string          `export:"UtmpIdentifier"`
	UtmpMode                 string          `export:"UtmpMode"`
	What                     string          `export:"What"`
	Where                    string          `export:"Where"`
	WorkingDirectory         string          `export:"WorkingDirectory"`
}

// newMountTypePropertiesFromMap generates a new MountTypeProperties given a systemd property map
func newMountTypePropertiesFromMap(m map[string]interface{}) *MountTypeProperties {
	s := &MountTypeProperties{}

	if val, ok := m["AmbientCapabilities"]; ok {
		s.AmbientCapabilities = val.(uint64)
	}

	if val, ok := m["AppArmorProfile"]; ok {
		s.AppArmorProfile = val.([]interface{})
	}

	if val, ok := m["BlockIOAccounting"]; ok {
		s.BlockIOAccounting = val.(bool)
	}

	if val, ok := m["BlockIODeviceWeight"]; ok {
		s.BlockIODeviceWeight = val.([][]interface{})
	}

	if val, ok := m["BlockIOReadBandwidth"]; ok {
		s.BlockIOReadBandwidth = val.([][]interface{})
	}

	if val, ok := m["BlockIOWeight"]; ok {
		s.BlockIOWeight = val.(uint64)
	}

	if val, ok := m["BlockIOWriteBandwidth"]; ok {
		s.BlockIOWriteBandwidth = val.([][]interface{})
	}

	if val, ok := m["CPUAccounting"]; ok {
		s.CPUAccounting = val.(bool)
	}

	if val, ok := m["CPUAffinity"]; ok {
		s.CPUAffinity = val.([]uint8)
	}

	if val, ok := m["CPUQuotaPerSecUSec"]; ok {
		s.CPUQuotaPerSecUSec = val.(uint64)
	}

	if val, ok := m["CPUSchedulingPolicy"]; ok {
		s.CPUSchedulingPolicy = val.(int32)
	}

	if val, ok := m["CPUSchedulingPriority"]; ok {
		s.CPUSchedulingPriority = val.(int32)
	}

	if val, ok := m["CPUSchedulingResetOnFork"]; ok {
		s.CPUSchedulingResetOnFork = val.(bool)
	}

	if val, ok := m["CPUShares"]; ok {
		s.CPUShares = val.(uint64)
	}

	if val, ok := m["CPUUsageNSec"]; ok {
		s.CPUUsageNSec = val.(uint64)
	}

	if val, ok := m["Capabilities"]; ok {
		s.Capabilities = val.(string)
	}

	if val, ok := m["CapabilityBoundingSet"]; ok {
		s.CapabilityBoundingSet = val.(uint64)
	}

	if val, ok := m["ControlGroup"]; ok {
		s.ControlGroup = val.(string)
	}

	if val, ok := m["ControlPID"]; ok {
		s.ControlPID = val.(uint32)
	}

	if val, ok := m["Delegate"]; ok {
		s.Delegate = val.(bool)
	}

	if val, ok := m["DeviceAllow"]; ok {
		s.DeviceAllow = val.([][]interface{})
	}

	if val, ok := m["DevicePolicy"]; ok {
		s.DevicePolicy = val.(string)
	}

	if val, ok := m["DirectoryMode"]; ok {
		s.DirectoryMode = val.(uint32)
	}

	if val, ok := m["Environment"]; ok {
		s.Environment = val.([]string)
	}

	if val, ok := m["EnvironmentFiles"]; ok {
		s.EnvironmentFiles = val.([][]interface{})
	}

	if val, ok := m["ExecMount"]; ok {
		s.ExecMount = val.([][]interface{})
	}

	if val, ok := m["ExecRemount"]; ok {
		s.ExecRemount = val.([][]interface{})
	}

	if val, ok := m["ExecUnmount"]; ok {
		s.ExecUnmount = val.([][]interface{})
	}

	if val, ok := m["Group"]; ok {
		s.Group = val.(string)
	}

	if val, ok := m["IOScheduling"]; ok {
		s.IOScheduling = val.(int32)
	}

	if val, ok := m["IgnoreSIGPIPE"]; ok {
		s.IgnoreSIGPIPE = val.(bool)
	}

	if val, ok := m["InaccessibleDirectories"]; ok {
		s.InaccessibleDirectories = val.([]string)
	}

	if val, ok := m["KillMode"]; ok {
		s.KillMode = val.(string)
	}

	if val, ok := m["KillSignal"]; ok {
		s.KillSignal = val.(int32)
	}

	if val, ok := m["LimitAS"]; ok {
		s.LimitAS = val.(uint64)
	}

	if val, ok := m["LimitASSoft"]; ok {
		s.LimitASSoft = val.(uint64)
	}

	if val, ok := m["LimitCORE"]; ok {
		s.LimitCORE = val.(uint64)
	}

	if val, ok := m["LimitCORESoft"]; ok {
		s.LimitCORESoft = val.(uint64)
	}

	if val, ok := m["LimitCPU"]; ok {
		s.LimitCPU = val.(uint64)
	}

	if val, ok := m["LimitCPUSoft"]; ok {
		s.LimitCPUSoft = val.(uint64)
	}

	if val, ok := m["LimitDATA"]; ok {
		s.LimitDATA = val.(uint64)
	}

	if val, ok := m["LimitDATASoft"]; ok {
		s.LimitDATASoft = val.(uint64)
	}

	if val, ok := m["LimitFSIZE"]; ok {
		s.LimitFSIZE = val.(uint64)
	}

	if val, ok := m["LimitFSIZESoft"]; ok {
		s.LimitFSIZESoft = val.(uint64)
	}

	if val, ok := m["LimitLOCKS"]; ok {
		s.LimitLOCKS = val.(uint64)
	}

	if val, ok := m["LimitLOCKSSoft"]; ok {
		s.LimitLOCKSSoft = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCK"]; ok {
		s.LimitMEMLOCK = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCKSoft"]; ok {
		s.LimitMEMLOCKSoft = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUE"]; ok {
		s.LimitMSGQUEUE = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUESoft"]; ok {
		s.LimitMSGQUEUESoft = val.(uint64)
	}

	if val, ok := m["LimitNICE"]; ok {
		s.LimitNICE = val.(uint64)
	}

	if val, ok := m["LimitNICESoft"]; ok {
		s.LimitNICESoft = val.(uint64)
	}

	if val, ok := m["LimitNOFILE"]; ok {
		s.LimitNOFILE = val.(uint64)
	}

	if val, ok := m["LimitNOFILESoft"]; ok {
		s.LimitNOFILESoft = val.(uint64)
	}

	if val, ok := m["LimitNPROC"]; ok {
		s.LimitNPROC = val.(uint64)
	}

	if val, ok := m["LimitNPROCSoft"]; ok {
		s.LimitNPROCSoft = val.(uint64)
	}

	if val, ok := m["LimitRSS"]; ok {
		s.LimitRSS = val.(uint64)
	}

	if val, ok := m["LimitRSSSoft"]; ok {
		s.LimitRSSSoft = val.(uint64)
	}

	if val, ok := m["LimitRTPRIO"]; ok {
		s.LimitRTPRIO = val.(uint64)
	}

	if val, ok := m["LimitRTPRIOSoft"]; ok {
		s.LimitRTPRIOSoft = val.(uint64)
	}

	if val, ok := m["LimitRTTIME"]; ok {
		s.LimitRTTIME = val.(uint64)
	}

	if val, ok := m["LimitRTTIMESoft"]; ok {
		s.LimitRTTIMESoft = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDING"]; ok {
		s.LimitSIGPENDING = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDINGSoft"]; ok {
		s.LimitSIGPENDINGSoft = val.(uint64)
	}

	if val, ok := m["LimitSTACK"]; ok {
		s.LimitSTACK = val.(uint64)
	}

	if val, ok := m["LimitSTACKSoft"]; ok {
		s.LimitSTACKSoft = val.(uint64)
	}

	if val, ok := m["MemoryAccounting"]; ok {
		s.MemoryAccounting = val.(bool)
	}

	if val, ok := m["MemoryCurrent"]; ok {
		s.MemoryCurrent = val.(uint64)
	}

	if val, ok := m["MemoryLimit"]; ok {
		s.MemoryLimit = val.(uint64)
	}

	if val, ok := m["MountFlags"]; ok {
		s.MountFlags = val.(uint64)
	}

	if val, ok := m["Nice"]; ok {
		s.Nice = val.(int32)
	}

	if val, ok := m["NoNewPrivileges"]; ok {
		s.NoNewPrivileges = val.(bool)
	}

	if val, ok := m["NonBlocking"]; ok {
		s.NonBlocking = val.(bool)
	}

	if val, ok := m["OOMScoreAdjust"]; ok {
		s.OOMScoreAdjust = val.(int32)
	}

	if val, ok := m["Options"]; ok {
		s.Options = val.(string)
	}

	if val, ok := m["PAMName"]; ok {
		s.PAMName = val.(string)
	}

	if val, ok := m["PassEnvironment"]; ok {
		s.PassEnvironment = val.([]string)
	}

	if val, ok := m["Personality"]; ok {
		s.Personality = val.(string)
	}

	if val, ok := m["PrivateDevices"]; ok {
		s.PrivateDevices = val.(bool)
	}

	if val, ok := m["PrivateNetwork"]; ok {
		s.PrivateNetwork = val.(bool)
	}

	if val, ok := m["PrivateTmp"]; ok {
		s.PrivateTmp = val.(bool)
	}

	if val, ok := m["ProtectHome"]; ok {
		s.ProtectHome = val.(string)
	}

	if val, ok := m["ProtectSystem"]; ok {
		s.ProtectSystem = val.(string)
	}

	if val, ok := m["ReadOnlyDirectories"]; ok {
		s.ReadOnlyDirectories = val.([]string)
	}

	if val, ok := m["ReadWriteDirectories"]; ok {
		s.ReadWriteDirectories = val.([]string)
	}

	if val, ok := m["RestrictAddressFamilies"]; ok {
		s.RestrictAddressFamilies = val.([]interface{})
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["RootDirectory"]; ok {
		s.RootDirectory = val.(string)
	}

	if val, ok := m["RuntimeDirectory"]; ok {
		s.RuntimeDirectory = val.([]string)
	}

	if val, ok := m["RuntimeDirectoryMode"]; ok {
		s.RuntimeDirectoryMode = val.(uint32)
	}

	if val, ok := m["SELinuxContext"]; ok {
		s.SELinuxContext = val.([]interface{})
	}

	if val, ok := m["SameProcessGroup"]; ok {
		s.SameProcessGroup = val.(bool)
	}

	if val, ok := m["SecureBits"]; ok {
		s.SecureBits = val.(int32)
	}

	if val, ok := m["SendSIGHUP"]; ok {
		s.SendSIGHUP = val.(bool)
	}

	if val, ok := m["SendSIGKILL"]; ok {
		s.SendSIGKILL = val.(bool)
	}

	if val, ok := m["Slice"]; ok {
		s.Slice = val.(string)
	}

	if val, ok := m["SloppyOptions"]; ok {
		s.SloppyOptions = val.(bool)
	}

	if val, ok := m["SmackProcessLabel"]; ok {
		s.SmackProcessLabel = val.([]interface{})
	}

	if val, ok := m["StandardError"]; ok {
		s.StandardError = val.(string)
	}

	if val, ok := m["StandardInput"]; ok {
		s.StandardInput = val.(string)
	}

	if val, ok := m["StandardOutput"]; ok {
		s.StandardOutput = val.(string)
	}

	if val, ok := m["StartupBlockIOWeight"]; ok {
		s.StartupBlockIOWeight = val.(uint64)
	}

	if val, ok := m["StartupCPUShares"]; ok {
		s.StartupCPUShares = val.(uint64)
	}

	if val, ok := m["SupplementaryGroups"]; ok {
		s.SupplementaryGroups = val.([]string)
	}

	if val, ok := m["SyslogFacility"]; ok {
		s.SyslogFacility = val.(int32)
	}

	if val, ok := m["SyslogIdentifier"]; ok {
		s.SyslogIdentifier = val.(string)
	}

	if val, ok := m["SyslogLevel"]; ok {
		s.SyslogLevel = val.(int32)
	}

	if val, ok := m["SyslogLevelPrefix"]; ok {
		s.SyslogLevelPrefix = val.(bool)
	}

	if val, ok := m["SyslogPriority"]; ok {
		s.SyslogPriority = val.(int32)
	}

	if val, ok := m["SystemCallArchitectures"]; ok {
		s.SystemCallArchitectures = val.([]string)
	}

	if val, ok := m["SystemCallErrorNumber"]; ok {
		s.SystemCallErrorNumber = val.(int32)
	}

	if val, ok := m["SystemCallFilter"]; ok {
		s.SystemCallFilter = val.([]interface{})
	}

	if val, ok := m["TTYPath"]; ok {
		s.TTYPath = val.(string)
	}

	if val, ok := m["TTYReset"]; ok {
		s.TTYReset = val.(bool)
	}

	if val, ok := m["TTYVHangup"]; ok {
		s.TTYVHangup = val.(bool)
	}

	if val, ok := m["TTYVTDisallocate"]; ok {
		s.TTYVTDisallocate = val.(bool)
	}

	if val, ok := m["TasksAccounting"]; ok {
		s.TasksAccounting = val.(bool)
	}

	if val, ok := m["TasksCurrent"]; ok {
		s.TasksCurrent = val.(uint64)
	}

	if val, ok := m["TasksMax"]; ok {
		s.TasksMax = val.(uint64)
	}

	if val, ok := m["TimeoutUSec"]; ok {
		s.TimeoutUSec = val.(uint64)
	}

	if val, ok := m["TimerSlackNSec"]; ok {
		s.TimerSlackNSec = val.(uint64)
	}

	if val, ok := m["Type"]; ok {
		s.Type = val.(string)
	}

	if val, ok := m["UMask"]; ok {
		s.UMask = val.(uint32)
	}

	if val, ok := m["User"]; ok {
		s.User = val.(string)
	}

	if val, ok := m["UtmpIdentifier"]; ok {
		s.UtmpIdentifier = val.(string)
	}

	if val, ok := m["UtmpMode"]; ok {
		s.UtmpMode = val.(string)
	}

	if val, ok := m["What"]; ok {
		s.What = val.(string)
	}

	if val, ok := m["Where"]; ok {
		s.Where = val.(string)
	}

	if val, ok := m["WorkingDirectory"]; ok {
		s.WorkingDirectory = val.(string)
	}
	return s
}

// AutomountTypeProperties wraps the dbus api for system with properties from this unit type
type AutomountTypeProperties struct {
	DirectoryMode   uint32 `export:"DirectoryMode"`
	Result          string `export:"Result"`
	TimeoutIdleUSec uint64 `export:"TimeoutIdleUSec"`
	Where           string `export:"Where"`
}

// newAutomountTypePropertiesFromMap generates a new AutomountTypeProperties given a systemd property map
func newAutomountTypePropertiesFromMap(m map[string]interface{}) *AutomountTypeProperties {
	s := &AutomountTypeProperties{}

	if val, ok := m["DirectoryMode"]; ok {
		s.DirectoryMode = val.(uint32)
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["TimeoutIdleUSec"]; ok {
		s.TimeoutIdleUSec = val.(uint64)
	}

	if val, ok := m["Where"]; ok {
		s.Where = val.(string)
	}
	return s
}

// SwapTypeProperties wraps the dbus api for system with properties from this unit type
type SwapTypeProperties struct {
	AmbientCapabilities      uint64          `export:"AmbientCapabilities"`
	AppArmorProfile          []interface{}   `export:"AppArmorProfile"`
	BlockIOAccounting        bool            `export:"BlockIOAccounting"`
	BlockIODeviceWeight      [][]interface{} `export:"BlockIODeviceWeight"`
	BlockIOReadBandwidth     [][]interface{} `export:"BlockIOReadBandwidth"`
	BlockIOWeight            uint64          `export:"BlockIOWeight"`
	BlockIOWriteBandwidth    [][]interface{} `export:"BlockIOWriteBandwidth"`
	CPUAccounting            bool            `export:"CPUAccounting"`
	CPUAffinity              []uint8         `export:"CPUAffinity"`
	CPUQuotaPerSecUSec       uint64          `export:"CPUQuotaPerSecUSec"`
	CPUSchedulingPolicy      int32           `export:"CPUSchedulingPolicy"`
	CPUSchedulingPriority    int32           `export:"CPUSchedulingPriority"`
	CPUSchedulingResetOnFork bool            `export:"CPUSchedulingResetOnFork"`
	CPUShares                uint64          `export:"CPUShares"`
	CPUUsageNSec             uint64          `export:"CPUUsageNSec"`
	Capabilities             string          `export:"Capabilities"`
	CapabilityBoundingSet    uint64          `export:"CapabilityBoundingSet"`
	ControlGroup             string          `export:"ControlGroup"`
	ControlPID               uint32          `export:"ControlPID"`
	Delegate                 bool            `export:"Delegate"`
	DeviceAllow              [][]interface{} `export:"DeviceAllow"`
	DevicePolicy             string          `export:"DevicePolicy"`
	Environment              []string        `export:"Environment"`
	EnvironmentFiles         [][]interface{} `export:"EnvironmentFiles"`
	ExecActivate             [][]interface{} `export:"ExecActivate"`
	ExecDeactivate           [][]interface{} `export:"ExecDeactivate"`
	Group                    string          `export:"Group"`
	IOScheduling             int32           `export:"IOScheduling"`
	IgnoreSIGPIPE            bool            `export:"IgnoreSIGPIPE"`
	InaccessibleDirectories  []string        `export:"InaccessibleDirectories"`
	KillMode                 string          `export:"KillMode"`
	KillSignal               int32           `export:"KillSignal"`
	LimitAS                  uint64          `export:"LimitAS"`
	LimitASSoft              uint64          `export:"LimitASSoft"`
	LimitCORE                uint64          `export:"LimitCORE"`
	LimitCORESoft            uint64          `export:"LimitCORESoft"`
	LimitCPU                 uint64          `export:"LimitCPU"`
	LimitCPUSoft             uint64          `export:"LimitCPUSoft"`
	LimitDATA                uint64          `export:"LimitDATA"`
	LimitDATASoft            uint64          `export:"LimitDATASoft"`
	LimitFSIZE               uint64          `export:"LimitFSIZE"`
	LimitFSIZESoft           uint64          `export:"LimitFSIZESoft"`
	LimitLOCKS               uint64          `export:"LimitLOCKS"`
	LimitLOCKSSoft           uint64          `export:"LimitLOCKSSoft"`
	LimitMEMLOCK             uint64          `export:"LimitMEMLOCK"`
	LimitMEMLOCKSoft         uint64          `export:"LimitMEMLOCKSoft"`
	LimitMSGQUEUE            uint64          `export:"LimitMSGQUEUE"`
	LimitMSGQUEUESoft        uint64          `export:"LimitMSGQUEUESoft"`
	LimitNICE                uint64          `export:"LimitNICE"`
	LimitNICESoft            uint64          `export:"LimitNICESoft"`
	LimitNOFILE              uint64          `export:"LimitNOFILE"`
	LimitNOFILESoft          uint64          `export:"LimitNOFILESoft"`
	LimitNPROC               uint64          `export:"LimitNPROC"`
	LimitNPROCSoft           uint64          `export:"LimitNPROCSoft"`
	LimitRSS                 uint64          `export:"LimitRSS"`
	LimitRSSSoft             uint64          `export:"LimitRSSSoft"`
	LimitRTPRIO              uint64          `export:"LimitRTPRIO"`
	LimitRTPRIOSoft          uint64          `export:"LimitRTPRIOSoft"`
	LimitRTTIME              uint64          `export:"LimitRTTIME"`
	LimitRTTIMESoft          uint64          `export:"LimitRTTIMESoft"`
	LimitSIGPENDING          uint64          `export:"LimitSIGPENDING"`
	LimitSIGPENDINGSoft      uint64          `export:"LimitSIGPENDINGSoft"`
	LimitSTACK               uint64          `export:"LimitSTACK"`
	LimitSTACKSoft           uint64          `export:"LimitSTACKSoft"`
	MemoryAccounting         bool            `export:"MemoryAccounting"`
	MemoryCurrent            uint64          `export:"MemoryCurrent"`
	MemoryLimit              uint64          `export:"MemoryLimit"`
	MountFlags               uint64          `export:"MountFlags"`
	Nice                     int32           `export:"Nice"`
	NoNewPrivileges          bool            `export:"NoNewPrivileges"`
	NonBlocking              bool            `export:"NonBlocking"`
	OOMScoreAdjust           int32           `export:"OOMScoreAdjust"`
	Options                  string          `export:"Options"`
	PAMName                  string          `export:"PAMName"`
	PassEnvironment          []string        `export:"PassEnvironment"`
	Personality              string          `export:"Personality"`
	Priority                 int32           `export:"Priority"`
	PrivateDevices           bool            `export:"PrivateDevices"`
	PrivateNetwork           bool            `export:"PrivateNetwork"`
	PrivateTmp               bool            `export:"PrivateTmp"`
	ProtectHome              string          `export:"ProtectHome"`
	ProtectSystem            string          `export:"ProtectSystem"`
	ReadOnlyDirectories      []string        `export:"ReadOnlyDirectories"`
	ReadWriteDirectories     []string        `export:"ReadWriteDirectories"`
	RestrictAddressFamilies  []interface{}   `export:"RestrictAddressFamilies"`
	Result                   string          `export:"Result"`
	RootDirectory            string          `export:"RootDirectory"`
	RuntimeDirectory         []string        `export:"RuntimeDirectory"`
	RuntimeDirectoryMode     uint32          `export:"RuntimeDirectoryMode"`
	SELinuxContext           []interface{}   `export:"SELinuxContext"`
	SameProcessGroup         bool            `export:"SameProcessGroup"`
	SecureBits               int32           `export:"SecureBits"`
	SendSIGHUP               bool            `export:"SendSIGHUP"`
	SendSIGKILL              bool            `export:"SendSIGKILL"`
	Slice                    string          `export:"Slice"`
	SmackProcessLabel        []interface{}   `export:"SmackProcessLabel"`
	StandardError            string          `export:"StandardError"`
	StandardInput            string          `export:"StandardInput"`
	StandardOutput           string          `export:"StandardOutput"`
	StartupBlockIOWeight     uint64          `export:"StartupBlockIOWeight"`
	StartupCPUShares         uint64          `export:"StartupCPUShares"`
	SupplementaryGroups      []string        `export:"SupplementaryGroups"`
	SyslogFacility           int32           `export:"SyslogFacility"`
	SyslogIdentifier         string          `export:"SyslogIdentifier"`
	SyslogLevel              int32           `export:"SyslogLevel"`
	SyslogLevelPrefix        bool            `export:"SyslogLevelPrefix"`
	SyslogPriority           int32           `export:"SyslogPriority"`
	SystemCallArchitectures  []string        `export:"SystemCallArchitectures"`
	SystemCallErrorNumber    int32           `export:"SystemCallErrorNumber"`
	SystemCallFilter         []interface{}   `export:"SystemCallFilter"`
	TTYPath                  string          `export:"TTYPath"`
	TTYReset                 bool            `export:"TTYReset"`
	TTYVHangup               bool            `export:"TTYVHangup"`
	TTYVTDisallocate         bool            `export:"TTYVTDisallocate"`
	TasksAccounting          bool            `export:"TasksAccounting"`
	TasksCurrent             uint64          `export:"TasksCurrent"`
	TasksMax                 uint64          `export:"TasksMax"`
	TimeoutUSec              uint64          `export:"TimeoutUSec"`
	TimerSlackNSec           uint64          `export:"TimerSlackNSec"`
	UMask                    uint32          `export:"UMask"`
	User                     string          `export:"User"`
	UtmpIdentifier           string          `export:"UtmpIdentifier"`
	UtmpMode                 string          `export:"UtmpMode"`
	What                     string          `export:"What"`
	WorkingDirectory         string          `export:"WorkingDirectory"`
}

// newSwapTypePropertiesFromMap generates a new SwapTypeProperties given a systemd property map
func newSwapTypePropertiesFromMap(m map[string]interface{}) *SwapTypeProperties {
	s := &SwapTypeProperties{}

	if val, ok := m["AmbientCapabilities"]; ok {
		s.AmbientCapabilities = val.(uint64)
	}

	if val, ok := m["AppArmorProfile"]; ok {
		s.AppArmorProfile = val.([]interface{})
	}

	if val, ok := m["BlockIOAccounting"]; ok {
		s.BlockIOAccounting = val.(bool)
	}

	if val, ok := m["BlockIODeviceWeight"]; ok {
		s.BlockIODeviceWeight = val.([][]interface{})
	}

	if val, ok := m["BlockIOReadBandwidth"]; ok {
		s.BlockIOReadBandwidth = val.([][]interface{})
	}

	if val, ok := m["BlockIOWeight"]; ok {
		s.BlockIOWeight = val.(uint64)
	}

	if val, ok := m["BlockIOWriteBandwidth"]; ok {
		s.BlockIOWriteBandwidth = val.([][]interface{})
	}

	if val, ok := m["CPUAccounting"]; ok {
		s.CPUAccounting = val.(bool)
	}

	if val, ok := m["CPUAffinity"]; ok {
		s.CPUAffinity = val.([]uint8)
	}

	if val, ok := m["CPUQuotaPerSecUSec"]; ok {
		s.CPUQuotaPerSecUSec = val.(uint64)
	}

	if val, ok := m["CPUSchedulingPolicy"]; ok {
		s.CPUSchedulingPolicy = val.(int32)
	}

	if val, ok := m["CPUSchedulingPriority"]; ok {
		s.CPUSchedulingPriority = val.(int32)
	}

	if val, ok := m["CPUSchedulingResetOnFork"]; ok {
		s.CPUSchedulingResetOnFork = val.(bool)
	}

	if val, ok := m["CPUShares"]; ok {
		s.CPUShares = val.(uint64)
	}

	if val, ok := m["CPUUsageNSec"]; ok {
		s.CPUUsageNSec = val.(uint64)
	}

	if val, ok := m["Capabilities"]; ok {
		s.Capabilities = val.(string)
	}

	if val, ok := m["CapabilityBoundingSet"]; ok {
		s.CapabilityBoundingSet = val.(uint64)
	}

	if val, ok := m["ControlGroup"]; ok {
		s.ControlGroup = val.(string)
	}

	if val, ok := m["ControlPID"]; ok {
		s.ControlPID = val.(uint32)
	}

	if val, ok := m["Delegate"]; ok {
		s.Delegate = val.(bool)
	}

	if val, ok := m["DeviceAllow"]; ok {
		s.DeviceAllow = val.([][]interface{})
	}

	if val, ok := m["DevicePolicy"]; ok {
		s.DevicePolicy = val.(string)
	}

	if val, ok := m["Environment"]; ok {
		s.Environment = val.([]string)
	}

	if val, ok := m["EnvironmentFiles"]; ok {
		s.EnvironmentFiles = val.([][]interface{})
	}

	if val, ok := m["ExecActivate"]; ok {
		s.ExecActivate = val.([][]interface{})
	}

	if val, ok := m["ExecDeactivate"]; ok {
		s.ExecDeactivate = val.([][]interface{})
	}

	if val, ok := m["Group"]; ok {
		s.Group = val.(string)
	}

	if val, ok := m["IOScheduling"]; ok {
		s.IOScheduling = val.(int32)
	}

	if val, ok := m["IgnoreSIGPIPE"]; ok {
		s.IgnoreSIGPIPE = val.(bool)
	}

	if val, ok := m["InaccessibleDirectories"]; ok {
		s.InaccessibleDirectories = val.([]string)
	}

	if val, ok := m["KillMode"]; ok {
		s.KillMode = val.(string)
	}

	if val, ok := m["KillSignal"]; ok {
		s.KillSignal = val.(int32)
	}

	if val, ok := m["LimitAS"]; ok {
		s.LimitAS = val.(uint64)
	}

	if val, ok := m["LimitASSoft"]; ok {
		s.LimitASSoft = val.(uint64)
	}

	if val, ok := m["LimitCORE"]; ok {
		s.LimitCORE = val.(uint64)
	}

	if val, ok := m["LimitCORESoft"]; ok {
		s.LimitCORESoft = val.(uint64)
	}

	if val, ok := m["LimitCPU"]; ok {
		s.LimitCPU = val.(uint64)
	}

	if val, ok := m["LimitCPUSoft"]; ok {
		s.LimitCPUSoft = val.(uint64)
	}

	if val, ok := m["LimitDATA"]; ok {
		s.LimitDATA = val.(uint64)
	}

	if val, ok := m["LimitDATASoft"]; ok {
		s.LimitDATASoft = val.(uint64)
	}

	if val, ok := m["LimitFSIZE"]; ok {
		s.LimitFSIZE = val.(uint64)
	}

	if val, ok := m["LimitFSIZESoft"]; ok {
		s.LimitFSIZESoft = val.(uint64)
	}

	if val, ok := m["LimitLOCKS"]; ok {
		s.LimitLOCKS = val.(uint64)
	}

	if val, ok := m["LimitLOCKSSoft"]; ok {
		s.LimitLOCKSSoft = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCK"]; ok {
		s.LimitMEMLOCK = val.(uint64)
	}

	if val, ok := m["LimitMEMLOCKSoft"]; ok {
		s.LimitMEMLOCKSoft = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUE"]; ok {
		s.LimitMSGQUEUE = val.(uint64)
	}

	if val, ok := m["LimitMSGQUEUESoft"]; ok {
		s.LimitMSGQUEUESoft = val.(uint64)
	}

	if val, ok := m["LimitNICE"]; ok {
		s.LimitNICE = val.(uint64)
	}

	if val, ok := m["LimitNICESoft"]; ok {
		s.LimitNICESoft = val.(uint64)
	}

	if val, ok := m["LimitNOFILE"]; ok {
		s.LimitNOFILE = val.(uint64)
	}

	if val, ok := m["LimitNOFILESoft"]; ok {
		s.LimitNOFILESoft = val.(uint64)
	}

	if val, ok := m["LimitNPROC"]; ok {
		s.LimitNPROC = val.(uint64)
	}

	if val, ok := m["LimitNPROCSoft"]; ok {
		s.LimitNPROCSoft = val.(uint64)
	}

	if val, ok := m["LimitRSS"]; ok {
		s.LimitRSS = val.(uint64)
	}

	if val, ok := m["LimitRSSSoft"]; ok {
		s.LimitRSSSoft = val.(uint64)
	}

	if val, ok := m["LimitRTPRIO"]; ok {
		s.LimitRTPRIO = val.(uint64)
	}

	if val, ok := m["LimitRTPRIOSoft"]; ok {
		s.LimitRTPRIOSoft = val.(uint64)
	}

	if val, ok := m["LimitRTTIME"]; ok {
		s.LimitRTTIME = val.(uint64)
	}

	if val, ok := m["LimitRTTIMESoft"]; ok {
		s.LimitRTTIMESoft = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDING"]; ok {
		s.LimitSIGPENDING = val.(uint64)
	}

	if val, ok := m["LimitSIGPENDINGSoft"]; ok {
		s.LimitSIGPENDINGSoft = val.(uint64)
	}

	if val, ok := m["LimitSTACK"]; ok {
		s.LimitSTACK = val.(uint64)
	}

	if val, ok := m["LimitSTACKSoft"]; ok {
		s.LimitSTACKSoft = val.(uint64)
	}

	if val, ok := m["MemoryAccounting"]; ok {
		s.MemoryAccounting = val.(bool)
	}

	if val, ok := m["MemoryCurrent"]; ok {
		s.MemoryCurrent = val.(uint64)
	}

	if val, ok := m["MemoryLimit"]; ok {
		s.MemoryLimit = val.(uint64)
	}

	if val, ok := m["MountFlags"]; ok {
		s.MountFlags = val.(uint64)
	}

	if val, ok := m["Nice"]; ok {
		s.Nice = val.(int32)
	}

	if val, ok := m["NoNewPrivileges"]; ok {
		s.NoNewPrivileges = val.(bool)
	}

	if val, ok := m["NonBlocking"]; ok {
		s.NonBlocking = val.(bool)
	}

	if val, ok := m["OOMScoreAdjust"]; ok {
		s.OOMScoreAdjust = val.(int32)
	}

	if val, ok := m["Options"]; ok {
		s.Options = val.(string)
	}

	if val, ok := m["PAMName"]; ok {
		s.PAMName = val.(string)
	}

	if val, ok := m["PassEnvironment"]; ok {
		s.PassEnvironment = val.([]string)
	}

	if val, ok := m["Personality"]; ok {
		s.Personality = val.(string)
	}

	if val, ok := m["Priority"]; ok {
		s.Priority = val.(int32)
	}

	if val, ok := m["PrivateDevices"]; ok {
		s.PrivateDevices = val.(bool)
	}

	if val, ok := m["PrivateNetwork"]; ok {
		s.PrivateNetwork = val.(bool)
	}

	if val, ok := m["PrivateTmp"]; ok {
		s.PrivateTmp = val.(bool)
	}

	if val, ok := m["ProtectHome"]; ok {
		s.ProtectHome = val.(string)
	}

	if val, ok := m["ProtectSystem"]; ok {
		s.ProtectSystem = val.(string)
	}

	if val, ok := m["ReadOnlyDirectories"]; ok {
		s.ReadOnlyDirectories = val.([]string)
	}

	if val, ok := m["ReadWriteDirectories"]; ok {
		s.ReadWriteDirectories = val.([]string)
	}

	if val, ok := m["RestrictAddressFamilies"]; ok {
		s.RestrictAddressFamilies = val.([]interface{})
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["RootDirectory"]; ok {
		s.RootDirectory = val.(string)
	}

	if val, ok := m["RuntimeDirectory"]; ok {
		s.RuntimeDirectory = val.([]string)
	}

	if val, ok := m["RuntimeDirectoryMode"]; ok {
		s.RuntimeDirectoryMode = val.(uint32)
	}

	if val, ok := m["SELinuxContext"]; ok {
		s.SELinuxContext = val.([]interface{})
	}

	if val, ok := m["SameProcessGroup"]; ok {
		s.SameProcessGroup = val.(bool)
	}

	if val, ok := m["SecureBits"]; ok {
		s.SecureBits = val.(int32)
	}

	if val, ok := m["SendSIGHUP"]; ok {
		s.SendSIGHUP = val.(bool)
	}

	if val, ok := m["SendSIGKILL"]; ok {
		s.SendSIGKILL = val.(bool)
	}

	if val, ok := m["Slice"]; ok {
		s.Slice = val.(string)
	}

	if val, ok := m["SmackProcessLabel"]; ok {
		s.SmackProcessLabel = val.([]interface{})
	}

	if val, ok := m["StandardError"]; ok {
		s.StandardError = val.(string)
	}

	if val, ok := m["StandardInput"]; ok {
		s.StandardInput = val.(string)
	}

	if val, ok := m["StandardOutput"]; ok {
		s.StandardOutput = val.(string)
	}

	if val, ok := m["StartupBlockIOWeight"]; ok {
		s.StartupBlockIOWeight = val.(uint64)
	}

	if val, ok := m["StartupCPUShares"]; ok {
		s.StartupCPUShares = val.(uint64)
	}

	if val, ok := m["SupplementaryGroups"]; ok {
		s.SupplementaryGroups = val.([]string)
	}

	if val, ok := m["SyslogFacility"]; ok {
		s.SyslogFacility = val.(int32)
	}

	if val, ok := m["SyslogIdentifier"]; ok {
		s.SyslogIdentifier = val.(string)
	}

	if val, ok := m["SyslogLevel"]; ok {
		s.SyslogLevel = val.(int32)
	}

	if val, ok := m["SyslogLevelPrefix"]; ok {
		s.SyslogLevelPrefix = val.(bool)
	}

	if val, ok := m["SyslogPriority"]; ok {
		s.SyslogPriority = val.(int32)
	}

	if val, ok := m["SystemCallArchitectures"]; ok {
		s.SystemCallArchitectures = val.([]string)
	}

	if val, ok := m["SystemCallErrorNumber"]; ok {
		s.SystemCallErrorNumber = val.(int32)
	}

	if val, ok := m["SystemCallFilter"]; ok {
		s.SystemCallFilter = val.([]interface{})
	}

	if val, ok := m["TTYPath"]; ok {
		s.TTYPath = val.(string)
	}

	if val, ok := m["TTYReset"]; ok {
		s.TTYReset = val.(bool)
	}

	if val, ok := m["TTYVHangup"]; ok {
		s.TTYVHangup = val.(bool)
	}

	if val, ok := m["TTYVTDisallocate"]; ok {
		s.TTYVTDisallocate = val.(bool)
	}

	if val, ok := m["TasksAccounting"]; ok {
		s.TasksAccounting = val.(bool)
	}

	if val, ok := m["TasksCurrent"]; ok {
		s.TasksCurrent = val.(uint64)
	}

	if val, ok := m["TasksMax"]; ok {
		s.TasksMax = val.(uint64)
	}

	if val, ok := m["TimeoutUSec"]; ok {
		s.TimeoutUSec = val.(uint64)
	}

	if val, ok := m["TimerSlackNSec"]; ok {
		s.TimerSlackNSec = val.(uint64)
	}

	if val, ok := m["UMask"]; ok {
		s.UMask = val.(uint32)
	}

	if val, ok := m["User"]; ok {
		s.User = val.(string)
	}

	if val, ok := m["UtmpIdentifier"]; ok {
		s.UtmpIdentifier = val.(string)
	}

	if val, ok := m["UtmpMode"]; ok {
		s.UtmpMode = val.(string)
	}

	if val, ok := m["What"]; ok {
		s.What = val.(string)
	}

	if val, ok := m["WorkingDirectory"]; ok {
		s.WorkingDirectory = val.(string)
	}
	return s
}

// TargetTypeProperties wraps the dbus api for system with properties from this unit type
type TargetTypeProperties struct {
}

// newTargetTypePropertiesFromMap generates a new TargetTypeProperties given a systemd property map
func newTargetTypePropertiesFromMap(m map[string]interface{}) *TargetTypeProperties {
	s := &TargetTypeProperties{}
	return s
}

// PathTypeProperties wraps the dbus api for system with properties from this unit type
type PathTypeProperties struct {
	DirectoryMode uint32          `export:"DirectoryMode"`
	MakeDirectory bool            `export:"MakeDirectory"`
	Paths         [][]interface{} `export:"Paths"`
	Result        string          `export:"Result"`
	Unit          string          `export:"Unit"`
}

// newPathTypePropertiesFromMap generates a new PathTypeProperties given a systemd property map
func newPathTypePropertiesFromMap(m map[string]interface{}) *PathTypeProperties {
	s := &PathTypeProperties{}

	if val, ok := m["DirectoryMode"]; ok {
		s.DirectoryMode = val.(uint32)
	}

	if val, ok := m["MakeDirectory"]; ok {
		s.MakeDirectory = val.(bool)
	}

	if val, ok := m["Paths"]; ok {
		s.Paths = val.([][]interface{})
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["Unit"]; ok {
		s.Unit = val.(string)
	}
	return s
}

// TimerTypeProperties wraps the dbus api for system with properties from this unit type
type TimerTypeProperties struct {
	AccuracyUSec             uint64          `export:"AccuracyUSec"`
	LastTriggerUSec          uint64          `export:"LastTriggerUSec"`
	LastTriggerUSecMonotonic uint64          `export:"LastTriggerUSecMonotonic"`
	NextElapseUSecMonotonic  uint64          `export:"NextElapseUSecMonotonic"`
	NextElapseUSecRealtime   uint64          `export:"NextElapseUSecRealtime"`
	Persistent               bool            `export:"Persistent"`
	RandomizedDelayUSec      uint64          `export:"RandomizedDelayUSec"`
	RemainAfterElapse        bool            `export:"RemainAfterElapse"`
	Result                   string          `export:"Result"`
	TimersCalendar           [][]interface{} `export:"TimersCalendar"`
	TimersMonotonic          [][]interface{} `export:"TimersMonotonic"`
	Unit                     string          `export:"Unit"`
	WakeSystem               bool            `export:"WakeSystem"`
}

// newTimerTypePropertiesFromMap generates a new TimerTypeProperties given a systemd property map
func newTimerTypePropertiesFromMap(m map[string]interface{}) *TimerTypeProperties {
	s := &TimerTypeProperties{}

	if val, ok := m["AccuracyUSec"]; ok {
		s.AccuracyUSec = val.(uint64)
	}

	if val, ok := m["LastTriggerUSec"]; ok {
		s.LastTriggerUSec = val.(uint64)
	}

	if val, ok := m["LastTriggerUSecMonotonic"]; ok {
		s.LastTriggerUSecMonotonic = val.(uint64)
	}

	if val, ok := m["NextElapseUSecMonotonic"]; ok {
		s.NextElapseUSecMonotonic = val.(uint64)
	}

	if val, ok := m["NextElapseUSecRealtime"]; ok {
		s.NextElapseUSecRealtime = val.(uint64)
	}

	if val, ok := m["Persistent"]; ok {
		s.Persistent = val.(bool)
	}

	if val, ok := m["RandomizedDelayUSec"]; ok {
		s.RandomizedDelayUSec = val.(uint64)
	}

	if val, ok := m["RemainAfterElapse"]; ok {
		s.RemainAfterElapse = val.(bool)
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["TimersCalendar"]; ok {
		s.TimersCalendar = val.([][]interface{})
	}

	if val, ok := m["TimersMonotonic"]; ok {
		s.TimersMonotonic = val.([][]interface{})
	}

	if val, ok := m["Unit"]; ok {
		s.Unit = val.(string)
	}

	if val, ok := m["WakeSystem"]; ok {
		s.WakeSystem = val.(bool)
	}
	return s
}

// SliceTypeProperties wraps the dbus api for system with properties from this unit type
type SliceTypeProperties struct {
	BlockIOAccounting     bool            `export:"BlockIOAccounting"`
	BlockIODeviceWeight   [][]interface{} `export:"BlockIODeviceWeight"`
	BlockIOReadBandwidth  [][]interface{} `export:"BlockIOReadBandwidth"`
	BlockIOWeight         uint64          `export:"BlockIOWeight"`
	BlockIOWriteBandwidth [][]interface{} `export:"BlockIOWriteBandwidth"`
	CPUAccounting         bool            `export:"CPUAccounting"`
	CPUQuotaPerSecUSec    uint64          `export:"CPUQuotaPerSecUSec"`
	CPUShares             uint64          `export:"CPUShares"`
	CPUUsageNSec          uint64          `export:"CPUUsageNSec"`
	ControlGroup          string          `export:"ControlGroup"`
	Delegate              bool            `export:"Delegate"`
	DeviceAllow           [][]interface{} `export:"DeviceAllow"`
	DevicePolicy          string          `export:"DevicePolicy"`
	MemoryAccounting      bool            `export:"MemoryAccounting"`
	MemoryCurrent         uint64          `export:"MemoryCurrent"`
	MemoryLimit           uint64          `export:"MemoryLimit"`
	Slice                 string          `export:"Slice"`
	StartupBlockIOWeight  uint64          `export:"StartupBlockIOWeight"`
	StartupCPUShares      uint64          `export:"StartupCPUShares"`
	TasksAccounting       bool            `export:"TasksAccounting"`
	TasksCurrent          uint64          `export:"TasksCurrent"`
	TasksMax              uint64          `export:"TasksMax"`
}

// newSliceTypePropertiesFromMap generates a new SliceTypeProperties given a systemd property map
func newSliceTypePropertiesFromMap(m map[string]interface{}) *SliceTypeProperties {
	s := &SliceTypeProperties{}

	if val, ok := m["BlockIOAccounting"]; ok {
		s.BlockIOAccounting = val.(bool)
	}

	if val, ok := m["BlockIODeviceWeight"]; ok {
		s.BlockIODeviceWeight = val.([][]interface{})
	}

	if val, ok := m["BlockIOReadBandwidth"]; ok {
		s.BlockIOReadBandwidth = val.([][]interface{})
	}

	if val, ok := m["BlockIOWeight"]; ok {
		s.BlockIOWeight = val.(uint64)
	}

	if val, ok := m["BlockIOWriteBandwidth"]; ok {
		s.BlockIOWriteBandwidth = val.([][]interface{})
	}

	if val, ok := m["CPUAccounting"]; ok {
		s.CPUAccounting = val.(bool)
	}

	if val, ok := m["CPUQuotaPerSecUSec"]; ok {
		s.CPUQuotaPerSecUSec = val.(uint64)
	}

	if val, ok := m["CPUShares"]; ok {
		s.CPUShares = val.(uint64)
	}

	if val, ok := m["CPUUsageNSec"]; ok {
		s.CPUUsageNSec = val.(uint64)
	}

	if val, ok := m["ControlGroup"]; ok {
		s.ControlGroup = val.(string)
	}

	if val, ok := m["Delegate"]; ok {
		s.Delegate = val.(bool)
	}

	if val, ok := m["DeviceAllow"]; ok {
		s.DeviceAllow = val.([][]interface{})
	}

	if val, ok := m["DevicePolicy"]; ok {
		s.DevicePolicy = val.(string)
	}

	if val, ok := m["MemoryAccounting"]; ok {
		s.MemoryAccounting = val.(bool)
	}

	if val, ok := m["MemoryCurrent"]; ok {
		s.MemoryCurrent = val.(uint64)
	}

	if val, ok := m["MemoryLimit"]; ok {
		s.MemoryLimit = val.(uint64)
	}

	if val, ok := m["Slice"]; ok {
		s.Slice = val.(string)
	}

	if val, ok := m["StartupBlockIOWeight"]; ok {
		s.StartupBlockIOWeight = val.(uint64)
	}

	if val, ok := m["StartupCPUShares"]; ok {
		s.StartupCPUShares = val.(uint64)
	}

	if val, ok := m["TasksAccounting"]; ok {
		s.TasksAccounting = val.(bool)
	}

	if val, ok := m["TasksCurrent"]; ok {
		s.TasksCurrent = val.(uint64)
	}

	if val, ok := m["TasksMax"]; ok {
		s.TasksMax = val.(uint64)
	}
	return s
}

// ScopeTypeProperties wraps the dbus api for system with properties from this unit type
type ScopeTypeProperties struct {
	BlockIOAccounting     bool            `export:"BlockIOAccounting"`
	BlockIODeviceWeight   [][]interface{} `export:"BlockIODeviceWeight"`
	BlockIOReadBandwidth  [][]interface{} `export:"BlockIOReadBandwidth"`
	BlockIOWeight         uint64          `export:"BlockIOWeight"`
	BlockIOWriteBandwidth [][]interface{} `export:"BlockIOWriteBandwidth"`
	CPUAccounting         bool            `export:"CPUAccounting"`
	CPUQuotaPerSecUSec    uint64          `export:"CPUQuotaPerSecUSec"`
	CPUShares             uint64          `export:"CPUShares"`
	CPUUsageNSec          uint64          `export:"CPUUsageNSec"`
	ControlGroup          string          `export:"ControlGroup"`
	Controller            string          `export:"Controller"`
	Delegate              bool            `export:"Delegate"`
	DeviceAllow           [][]interface{} `export:"DeviceAllow"`
	DevicePolicy          string          `export:"DevicePolicy"`
	KillMode              string          `export:"KillMode"`
	KillSignal            int32           `export:"KillSignal"`
	MemoryAccounting      bool            `export:"MemoryAccounting"`
	MemoryCurrent         uint64          `export:"MemoryCurrent"`
	MemoryLimit           uint64          `export:"MemoryLimit"`
	Result                string          `export:"Result"`
	SendSIGHUP            bool            `export:"SendSIGHUP"`
	SendSIGKILL           bool            `export:"SendSIGKILL"`
	Slice                 string          `export:"Slice"`
	StartupBlockIOWeight  uint64          `export:"StartupBlockIOWeight"`
	StartupCPUShares      uint64          `export:"StartupCPUShares"`
	TasksAccounting       bool            `export:"TasksAccounting"`
	TasksCurrent          uint64          `export:"TasksCurrent"`
	TasksMax              uint64          `export:"TasksMax"`
	TimeoutStopUSec       uint64          `export:"TimeoutStopUSec"`
}

// newScopeTypePropertiesFromMap generates a new ScopeTypeProperties given a systemd property map
func newScopeTypePropertiesFromMap(m map[string]interface{}) *ScopeTypeProperties {
	s := &ScopeTypeProperties{}

	if val, ok := m["BlockIOAccounting"]; ok {
		s.BlockIOAccounting = val.(bool)
	}

	if val, ok := m["BlockIODeviceWeight"]; ok {
		s.BlockIODeviceWeight = val.([][]interface{})
	}

	if val, ok := m["BlockIOReadBandwidth"]; ok {
		s.BlockIOReadBandwidth = val.([][]interface{})
	}

	if val, ok := m["BlockIOWeight"]; ok {
		s.BlockIOWeight = val.(uint64)
	}

	if val, ok := m["BlockIOWriteBandwidth"]; ok {
		s.BlockIOWriteBandwidth = val.([][]interface{})
	}

	if val, ok := m["CPUAccounting"]; ok {
		s.CPUAccounting = val.(bool)
	}

	if val, ok := m["CPUQuotaPerSecUSec"]; ok {
		s.CPUQuotaPerSecUSec = val.(uint64)
	}

	if val, ok := m["CPUShares"]; ok {
		s.CPUShares = val.(uint64)
	}

	if val, ok := m["CPUUsageNSec"]; ok {
		s.CPUUsageNSec = val.(uint64)
	}

	if val, ok := m["ControlGroup"]; ok {
		s.ControlGroup = val.(string)
	}

	if val, ok := m["Controller"]; ok {
		s.Controller = val.(string)
	}

	if val, ok := m["Delegate"]; ok {
		s.Delegate = val.(bool)
	}

	if val, ok := m["DeviceAllow"]; ok {
		s.DeviceAllow = val.([][]interface{})
	}

	if val, ok := m["DevicePolicy"]; ok {
		s.DevicePolicy = val.(string)
	}

	if val, ok := m["KillMode"]; ok {
		s.KillMode = val.(string)
	}

	if val, ok := m["KillSignal"]; ok {
		s.KillSignal = val.(int32)
	}

	if val, ok := m["MemoryAccounting"]; ok {
		s.MemoryAccounting = val.(bool)
	}

	if val, ok := m["MemoryCurrent"]; ok {
		s.MemoryCurrent = val.(uint64)
	}

	if val, ok := m["MemoryLimit"]; ok {
		s.MemoryLimit = val.(uint64)
	}

	if val, ok := m["Result"]; ok {
		s.Result = val.(string)
	}

	if val, ok := m["SendSIGHUP"]; ok {
		s.SendSIGHUP = val.(bool)
	}

	if val, ok := m["SendSIGKILL"]; ok {
		s.SendSIGKILL = val.(bool)
	}

	if val, ok := m["Slice"]; ok {
		s.Slice = val.(string)
	}

	if val, ok := m["StartupBlockIOWeight"]; ok {
		s.StartupBlockIOWeight = val.(uint64)
	}

	if val, ok := m["StartupCPUShares"]; ok {
		s.StartupCPUShares = val.(uint64)
	}

	if val, ok := m["TasksAccounting"]; ok {
		s.TasksAccounting = val.(bool)
	}

	if val, ok := m["TasksCurrent"]; ok {
		s.TasksCurrent = val.(uint64)
	}

	if val, ok := m["TasksMax"]; ok {
		s.TasksMax = val.(uint64)
	}

	if val, ok := m["TimeoutStopUSec"]; ok {
		s.TimeoutStopUSec = val.(uint64)
	}
	return s
}
